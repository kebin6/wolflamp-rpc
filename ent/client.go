// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	uuid "github.com/gofrs/uuid/v5"
	"github.com/kebin6/wolflamp-rpc/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/kebin6/wolflamp-rpc/ent/banner"
	"github.com/kebin6/wolflamp-rpc/ent/exchange"
	"github.com/kebin6/wolflamp-rpc/ent/file"
	"github.com/kebin6/wolflamp-rpc/ent/order"
	"github.com/kebin6/wolflamp-rpc/ent/origininvitecode"
	"github.com/kebin6/wolflamp-rpc/ent/player"
	"github.com/kebin6/wolflamp-rpc/ent/reward"
	"github.com/kebin6/wolflamp-rpc/ent/round"
	"github.com/kebin6/wolflamp-rpc/ent/roundinvest"
	"github.com/kebin6/wolflamp-rpc/ent/roundlambfold"
	"github.com/kebin6/wolflamp-rpc/ent/setting"
	"github.com/kebin6/wolflamp-rpc/ent/statement"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Banner is the client for interacting with the Banner builders.
	Banner *BannerClient
	// Exchange is the client for interacting with the Exchange builders.
	Exchange *ExchangeClient
	// File is the client for interacting with the File builders.
	File *FileClient
	// Order is the client for interacting with the Order builders.
	Order *OrderClient
	// OriginInviteCode is the client for interacting with the OriginInviteCode builders.
	OriginInviteCode *OriginInviteCodeClient
	// Player is the client for interacting with the Player builders.
	Player *PlayerClient
	// Reward is the client for interacting with the Reward builders.
	Reward *RewardClient
	// Round is the client for interacting with the Round builders.
	Round *RoundClient
	// RoundInvest is the client for interacting with the RoundInvest builders.
	RoundInvest *RoundInvestClient
	// RoundLambFold is the client for interacting with the RoundLambFold builders.
	RoundLambFold *RoundLambFoldClient
	// Setting is the client for interacting with the Setting builders.
	Setting *SettingClient
	// Statement is the client for interacting with the Statement builders.
	Statement *StatementClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Banner = NewBannerClient(c.config)
	c.Exchange = NewExchangeClient(c.config)
	c.File = NewFileClient(c.config)
	c.Order = NewOrderClient(c.config)
	c.OriginInviteCode = NewOriginInviteCodeClient(c.config)
	c.Player = NewPlayerClient(c.config)
	c.Reward = NewRewardClient(c.config)
	c.Round = NewRoundClient(c.config)
	c.RoundInvest = NewRoundInvestClient(c.config)
	c.RoundLambFold = NewRoundLambFoldClient(c.config)
	c.Setting = NewSettingClient(c.config)
	c.Statement = NewStatementClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Banner:           NewBannerClient(cfg),
		Exchange:         NewExchangeClient(cfg),
		File:             NewFileClient(cfg),
		Order:            NewOrderClient(cfg),
		OriginInviteCode: NewOriginInviteCodeClient(cfg),
		Player:           NewPlayerClient(cfg),
		Reward:           NewRewardClient(cfg),
		Round:            NewRoundClient(cfg),
		RoundInvest:      NewRoundInvestClient(cfg),
		RoundLambFold:    NewRoundLambFoldClient(cfg),
		Setting:          NewSettingClient(cfg),
		Statement:        NewStatementClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Banner:           NewBannerClient(cfg),
		Exchange:         NewExchangeClient(cfg),
		File:             NewFileClient(cfg),
		Order:            NewOrderClient(cfg),
		OriginInviteCode: NewOriginInviteCodeClient(cfg),
		Player:           NewPlayerClient(cfg),
		Reward:           NewRewardClient(cfg),
		Round:            NewRoundClient(cfg),
		RoundInvest:      NewRoundInvestClient(cfg),
		RoundLambFold:    NewRoundLambFoldClient(cfg),
		Setting:          NewSettingClient(cfg),
		Statement:        NewStatementClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Banner.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Banner, c.Exchange, c.File, c.Order, c.OriginInviteCode, c.Player, c.Reward,
		c.Round, c.RoundInvest, c.RoundLambFold, c.Setting, c.Statement,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Banner, c.Exchange, c.File, c.Order, c.OriginInviteCode, c.Player, c.Reward,
		c.Round, c.RoundInvest, c.RoundLambFold, c.Setting, c.Statement,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *BannerMutation:
		return c.Banner.mutate(ctx, m)
	case *ExchangeMutation:
		return c.Exchange.mutate(ctx, m)
	case *FileMutation:
		return c.File.mutate(ctx, m)
	case *OrderMutation:
		return c.Order.mutate(ctx, m)
	case *OriginInviteCodeMutation:
		return c.OriginInviteCode.mutate(ctx, m)
	case *PlayerMutation:
		return c.Player.mutate(ctx, m)
	case *RewardMutation:
		return c.Reward.mutate(ctx, m)
	case *RoundMutation:
		return c.Round.mutate(ctx, m)
	case *RoundInvestMutation:
		return c.RoundInvest.mutate(ctx, m)
	case *RoundLambFoldMutation:
		return c.RoundLambFold.mutate(ctx, m)
	case *SettingMutation:
		return c.Setting.mutate(ctx, m)
	case *StatementMutation:
		return c.Statement.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// BannerClient is a client for the Banner schema.
type BannerClient struct {
	config
}

// NewBannerClient returns a client for the Banner from the given config.
func NewBannerClient(c config) *BannerClient {
	return &BannerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `banner.Hooks(f(g(h())))`.
func (c *BannerClient) Use(hooks ...Hook) {
	c.hooks.Banner = append(c.hooks.Banner, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `banner.Intercept(f(g(h())))`.
func (c *BannerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Banner = append(c.inters.Banner, interceptors...)
}

// Create returns a builder for creating a Banner entity.
func (c *BannerClient) Create() *BannerCreate {
	mutation := newBannerMutation(c.config, OpCreate)
	return &BannerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Banner entities.
func (c *BannerClient) CreateBulk(builders ...*BannerCreate) *BannerCreateBulk {
	return &BannerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BannerClient) MapCreateBulk(slice any, setFunc func(*BannerCreate, int)) *BannerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BannerCreateBulk{err: fmt.Errorf("calling to BannerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BannerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BannerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Banner.
func (c *BannerClient) Update() *BannerUpdate {
	mutation := newBannerMutation(c.config, OpUpdate)
	return &BannerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BannerClient) UpdateOne(b *Banner) *BannerUpdateOne {
	mutation := newBannerMutation(c.config, OpUpdateOne, withBanner(b))
	return &BannerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BannerClient) UpdateOneID(id uint64) *BannerUpdateOne {
	mutation := newBannerMutation(c.config, OpUpdateOne, withBannerID(id))
	return &BannerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Banner.
func (c *BannerClient) Delete() *BannerDelete {
	mutation := newBannerMutation(c.config, OpDelete)
	return &BannerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BannerClient) DeleteOne(b *Banner) *BannerDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BannerClient) DeleteOneID(id uint64) *BannerDeleteOne {
	builder := c.Delete().Where(banner.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BannerDeleteOne{builder}
}

// Query returns a query builder for Banner.
func (c *BannerClient) Query() *BannerQuery {
	return &BannerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBanner},
		inters: c.Interceptors(),
	}
}

// Get returns a Banner entity by its id.
func (c *BannerClient) Get(ctx context.Context, id uint64) (*Banner, error) {
	return c.Query().Where(banner.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BannerClient) GetX(ctx context.Context, id uint64) *Banner {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFile queries the file edge of a Banner.
func (c *BannerClient) QueryFile(b *Banner) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(banner.Table, banner.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, banner.FileTable, banner.FileColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BannerClient) Hooks() []Hook {
	return c.hooks.Banner
}

// Interceptors returns the client interceptors.
func (c *BannerClient) Interceptors() []Interceptor {
	return c.inters.Banner
}

func (c *BannerClient) mutate(ctx context.Context, m *BannerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BannerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BannerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BannerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BannerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Banner mutation op: %q", m.Op())
	}
}

// ExchangeClient is a client for the Exchange schema.
type ExchangeClient struct {
	config
}

// NewExchangeClient returns a client for the Exchange from the given config.
func NewExchangeClient(c config) *ExchangeClient {
	return &ExchangeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `exchange.Hooks(f(g(h())))`.
func (c *ExchangeClient) Use(hooks ...Hook) {
	c.hooks.Exchange = append(c.hooks.Exchange, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `exchange.Intercept(f(g(h())))`.
func (c *ExchangeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Exchange = append(c.inters.Exchange, interceptors...)
}

// Create returns a builder for creating a Exchange entity.
func (c *ExchangeClient) Create() *ExchangeCreate {
	mutation := newExchangeMutation(c.config, OpCreate)
	return &ExchangeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Exchange entities.
func (c *ExchangeClient) CreateBulk(builders ...*ExchangeCreate) *ExchangeCreateBulk {
	return &ExchangeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExchangeClient) MapCreateBulk(slice any, setFunc func(*ExchangeCreate, int)) *ExchangeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExchangeCreateBulk{err: fmt.Errorf("calling to ExchangeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExchangeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExchangeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Exchange.
func (c *ExchangeClient) Update() *ExchangeUpdate {
	mutation := newExchangeMutation(c.config, OpUpdate)
	return &ExchangeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExchangeClient) UpdateOne(e *Exchange) *ExchangeUpdateOne {
	mutation := newExchangeMutation(c.config, OpUpdateOne, withExchange(e))
	return &ExchangeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExchangeClient) UpdateOneID(id uint64) *ExchangeUpdateOne {
	mutation := newExchangeMutation(c.config, OpUpdateOne, withExchangeID(id))
	return &ExchangeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Exchange.
func (c *ExchangeClient) Delete() *ExchangeDelete {
	mutation := newExchangeMutation(c.config, OpDelete)
	return &ExchangeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExchangeClient) DeleteOne(e *Exchange) *ExchangeDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExchangeClient) DeleteOneID(id uint64) *ExchangeDeleteOne {
	builder := c.Delete().Where(exchange.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExchangeDeleteOne{builder}
}

// Query returns a query builder for Exchange.
func (c *ExchangeClient) Query() *ExchangeQuery {
	return &ExchangeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExchange},
		inters: c.Interceptors(),
	}
}

// Get returns a Exchange entity by its id.
func (c *ExchangeClient) Get(ctx context.Context, id uint64) (*Exchange, error) {
	return c.Query().Where(exchange.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExchangeClient) GetX(ctx context.Context, id uint64) *Exchange {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ExchangeClient) Hooks() []Hook {
	return c.hooks.Exchange
}

// Interceptors returns the client interceptors.
func (c *ExchangeClient) Interceptors() []Interceptor {
	return c.inters.Exchange
}

func (c *ExchangeClient) mutate(ctx context.Context, m *ExchangeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExchangeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExchangeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExchangeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExchangeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Exchange mutation op: %q", m.Op())
	}
}

// FileClient is a client for the File schema.
type FileClient struct {
	config
}

// NewFileClient returns a client for the File from the given config.
func NewFileClient(c config) *FileClient {
	return &FileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `file.Hooks(f(g(h())))`.
func (c *FileClient) Use(hooks ...Hook) {
	c.hooks.File = append(c.hooks.File, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `file.Intercept(f(g(h())))`.
func (c *FileClient) Intercept(interceptors ...Interceptor) {
	c.inters.File = append(c.inters.File, interceptors...)
}

// Create returns a builder for creating a File entity.
func (c *FileClient) Create() *FileCreate {
	mutation := newFileMutation(c.config, OpCreate)
	return &FileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of File entities.
func (c *FileClient) CreateBulk(builders ...*FileCreate) *FileCreateBulk {
	return &FileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileClient) MapCreateBulk(slice any, setFunc func(*FileCreate, int)) *FileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileCreateBulk{err: fmt.Errorf("calling to FileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for File.
func (c *FileClient) Update() *FileUpdate {
	mutation := newFileMutation(c.config, OpUpdate)
	return &FileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileClient) UpdateOne(f *File) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFile(f))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileClient) UpdateOneID(id uuid.UUID) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFileID(id))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for File.
func (c *FileClient) Delete() *FileDelete {
	mutation := newFileMutation(c.config, OpDelete)
	return &FileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileClient) DeleteOne(f *File) *FileDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileClient) DeleteOneID(id uuid.UUID) *FileDeleteOne {
	builder := c.Delete().Where(file.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDeleteOne{builder}
}

// Query returns a query builder for File.
func (c *FileClient) Query() *FileQuery {
	return &FileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFile},
		inters: c.Interceptors(),
	}
}

// Get returns a File entity by its id.
func (c *FileClient) Get(ctx context.Context, id uuid.UUID) (*File, error) {
	return c.Query().Where(file.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileClient) GetX(ctx context.Context, id uuid.UUID) *File {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBanner queries the banner edge of a File.
func (c *FileClient) QueryBanner(f *File) *BannerQuery {
	query := (&BannerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(banner.Table, banner.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, file.BannerTable, file.BannerColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileClient) Hooks() []Hook {
	return c.hooks.File
}

// Interceptors returns the client interceptors.
func (c *FileClient) Interceptors() []Interceptor {
	return c.inters.File
}

func (c *FileClient) mutate(ctx context.Context, m *FileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown File mutation op: %q", m.Op())
	}
}

// OrderClient is a client for the Order schema.
type OrderClient struct {
	config
}

// NewOrderClient returns a client for the Order from the given config.
func NewOrderClient(c config) *OrderClient {
	return &OrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `order.Hooks(f(g(h())))`.
func (c *OrderClient) Use(hooks ...Hook) {
	c.hooks.Order = append(c.hooks.Order, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `order.Intercept(f(g(h())))`.
func (c *OrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Order = append(c.inters.Order, interceptors...)
}

// Create returns a builder for creating a Order entity.
func (c *OrderClient) Create() *OrderCreate {
	mutation := newOrderMutation(c.config, OpCreate)
	return &OrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Order entities.
func (c *OrderClient) CreateBulk(builders ...*OrderCreate) *OrderCreateBulk {
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderClient) MapCreateBulk(slice any, setFunc func(*OrderCreate, int)) *OrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderCreateBulk{err: fmt.Errorf("calling to OrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Order.
func (c *OrderClient) Update() *OrderUpdate {
	mutation := newOrderMutation(c.config, OpUpdate)
	return &OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderClient) UpdateOne(o *Order) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrder(o))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderClient) UpdateOneID(id uint64) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrderID(id))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Order.
func (c *OrderClient) Delete() *OrderDelete {
	mutation := newOrderMutation(c.config, OpDelete)
	return &OrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderClient) DeleteOne(o *Order) *OrderDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderClient) DeleteOneID(id uint64) *OrderDeleteOne {
	builder := c.Delete().Where(order.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderDeleteOne{builder}
}

// Query returns a query builder for Order.
func (c *OrderClient) Query() *OrderQuery {
	return &OrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a Order entity by its id.
func (c *OrderClient) Get(ctx context.Context, id uint64) (*Order, error) {
	return c.Query().Where(order.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderClient) GetX(ctx context.Context, id uint64) *Order {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrderClient) Hooks() []Hook {
	return c.hooks.Order
}

// Interceptors returns the client interceptors.
func (c *OrderClient) Interceptors() []Interceptor {
	return c.inters.Order
}

func (c *OrderClient) mutate(ctx context.Context, m *OrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Order mutation op: %q", m.Op())
	}
}

// OriginInviteCodeClient is a client for the OriginInviteCode schema.
type OriginInviteCodeClient struct {
	config
}

// NewOriginInviteCodeClient returns a client for the OriginInviteCode from the given config.
func NewOriginInviteCodeClient(c config) *OriginInviteCodeClient {
	return &OriginInviteCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `origininvitecode.Hooks(f(g(h())))`.
func (c *OriginInviteCodeClient) Use(hooks ...Hook) {
	c.hooks.OriginInviteCode = append(c.hooks.OriginInviteCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `origininvitecode.Intercept(f(g(h())))`.
func (c *OriginInviteCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.OriginInviteCode = append(c.inters.OriginInviteCode, interceptors...)
}

// Create returns a builder for creating a OriginInviteCode entity.
func (c *OriginInviteCodeClient) Create() *OriginInviteCodeCreate {
	mutation := newOriginInviteCodeMutation(c.config, OpCreate)
	return &OriginInviteCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OriginInviteCode entities.
func (c *OriginInviteCodeClient) CreateBulk(builders ...*OriginInviteCodeCreate) *OriginInviteCodeCreateBulk {
	return &OriginInviteCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OriginInviteCodeClient) MapCreateBulk(slice any, setFunc func(*OriginInviteCodeCreate, int)) *OriginInviteCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OriginInviteCodeCreateBulk{err: fmt.Errorf("calling to OriginInviteCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OriginInviteCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OriginInviteCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OriginInviteCode.
func (c *OriginInviteCodeClient) Update() *OriginInviteCodeUpdate {
	mutation := newOriginInviteCodeMutation(c.config, OpUpdate)
	return &OriginInviteCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OriginInviteCodeClient) UpdateOne(oic *OriginInviteCode) *OriginInviteCodeUpdateOne {
	mutation := newOriginInviteCodeMutation(c.config, OpUpdateOne, withOriginInviteCode(oic))
	return &OriginInviteCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OriginInviteCodeClient) UpdateOneID(id uint64) *OriginInviteCodeUpdateOne {
	mutation := newOriginInviteCodeMutation(c.config, OpUpdateOne, withOriginInviteCodeID(id))
	return &OriginInviteCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OriginInviteCode.
func (c *OriginInviteCodeClient) Delete() *OriginInviteCodeDelete {
	mutation := newOriginInviteCodeMutation(c.config, OpDelete)
	return &OriginInviteCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OriginInviteCodeClient) DeleteOne(oic *OriginInviteCode) *OriginInviteCodeDeleteOne {
	return c.DeleteOneID(oic.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OriginInviteCodeClient) DeleteOneID(id uint64) *OriginInviteCodeDeleteOne {
	builder := c.Delete().Where(origininvitecode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OriginInviteCodeDeleteOne{builder}
}

// Query returns a query builder for OriginInviteCode.
func (c *OriginInviteCodeClient) Query() *OriginInviteCodeQuery {
	return &OriginInviteCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOriginInviteCode},
		inters: c.Interceptors(),
	}
}

// Get returns a OriginInviteCode entity by its id.
func (c *OriginInviteCodeClient) Get(ctx context.Context, id uint64) (*OriginInviteCode, error) {
	return c.Query().Where(origininvitecode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OriginInviteCodeClient) GetX(ctx context.Context, id uint64) *OriginInviteCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OriginInviteCodeClient) Hooks() []Hook {
	return c.hooks.OriginInviteCode
}

// Interceptors returns the client interceptors.
func (c *OriginInviteCodeClient) Interceptors() []Interceptor {
	return c.inters.OriginInviteCode
}

func (c *OriginInviteCodeClient) mutate(ctx context.Context, m *OriginInviteCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OriginInviteCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OriginInviteCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OriginInviteCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OriginInviteCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OriginInviteCode mutation op: %q", m.Op())
	}
}

// PlayerClient is a client for the Player schema.
type PlayerClient struct {
	config
}

// NewPlayerClient returns a client for the Player from the given config.
func NewPlayerClient(c config) *PlayerClient {
	return &PlayerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `player.Hooks(f(g(h())))`.
func (c *PlayerClient) Use(hooks ...Hook) {
	c.hooks.Player = append(c.hooks.Player, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `player.Intercept(f(g(h())))`.
func (c *PlayerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Player = append(c.inters.Player, interceptors...)
}

// Create returns a builder for creating a Player entity.
func (c *PlayerClient) Create() *PlayerCreate {
	mutation := newPlayerMutation(c.config, OpCreate)
	return &PlayerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Player entities.
func (c *PlayerClient) CreateBulk(builders ...*PlayerCreate) *PlayerCreateBulk {
	return &PlayerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlayerClient) MapCreateBulk(slice any, setFunc func(*PlayerCreate, int)) *PlayerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlayerCreateBulk{err: fmt.Errorf("calling to PlayerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlayerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlayerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Player.
func (c *PlayerClient) Update() *PlayerUpdate {
	mutation := newPlayerMutation(c.config, OpUpdate)
	return &PlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlayerClient) UpdateOne(pl *Player) *PlayerUpdateOne {
	mutation := newPlayerMutation(c.config, OpUpdateOne, withPlayer(pl))
	return &PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlayerClient) UpdateOneID(id uint64) *PlayerUpdateOne {
	mutation := newPlayerMutation(c.config, OpUpdateOne, withPlayerID(id))
	return &PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Player.
func (c *PlayerClient) Delete() *PlayerDelete {
	mutation := newPlayerMutation(c.config, OpDelete)
	return &PlayerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlayerClient) DeleteOne(pl *Player) *PlayerDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlayerClient) DeleteOneID(id uint64) *PlayerDeleteOne {
	builder := c.Delete().Where(player.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlayerDeleteOne{builder}
}

// Query returns a query builder for Player.
func (c *PlayerClient) Query() *PlayerQuery {
	return &PlayerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlayer},
		inters: c.Interceptors(),
	}
}

// Get returns a Player entity by its id.
func (c *PlayerClient) Get(ctx context.Context, id uint64) (*Player, error) {
	return c.Query().Where(player.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlayerClient) GetX(ctx context.Context, id uint64) *Player {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInviter queries the inviter edge of a Player.
func (c *PlayerClient) QueryInviter(pl *Player) *PlayerQuery {
	query := (&PlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, player.InviterTable, player.InviterColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvitees queries the invitees edge of a Player.
func (c *PlayerClient) QueryInvitees(pl *Player) *PlayerQuery {
	query := (&PlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, player.InviteesTable, player.InviteesColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlayerClient) Hooks() []Hook {
	return c.hooks.Player
}

// Interceptors returns the client interceptors.
func (c *PlayerClient) Interceptors() []Interceptor {
	return c.inters.Player
}

func (c *PlayerClient) mutate(ctx context.Context, m *PlayerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlayerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlayerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Player mutation op: %q", m.Op())
	}
}

// RewardClient is a client for the Reward schema.
type RewardClient struct {
	config
}

// NewRewardClient returns a client for the Reward from the given config.
func NewRewardClient(c config) *RewardClient {
	return &RewardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reward.Hooks(f(g(h())))`.
func (c *RewardClient) Use(hooks ...Hook) {
	c.hooks.Reward = append(c.hooks.Reward, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reward.Intercept(f(g(h())))`.
func (c *RewardClient) Intercept(interceptors ...Interceptor) {
	c.inters.Reward = append(c.inters.Reward, interceptors...)
}

// Create returns a builder for creating a Reward entity.
func (c *RewardClient) Create() *RewardCreate {
	mutation := newRewardMutation(c.config, OpCreate)
	return &RewardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Reward entities.
func (c *RewardClient) CreateBulk(builders ...*RewardCreate) *RewardCreateBulk {
	return &RewardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RewardClient) MapCreateBulk(slice any, setFunc func(*RewardCreate, int)) *RewardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RewardCreateBulk{err: fmt.Errorf("calling to RewardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RewardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RewardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Reward.
func (c *RewardClient) Update() *RewardUpdate {
	mutation := newRewardMutation(c.config, OpUpdate)
	return &RewardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RewardClient) UpdateOne(r *Reward) *RewardUpdateOne {
	mutation := newRewardMutation(c.config, OpUpdateOne, withReward(r))
	return &RewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RewardClient) UpdateOneID(id uint64) *RewardUpdateOne {
	mutation := newRewardMutation(c.config, OpUpdateOne, withRewardID(id))
	return &RewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Reward.
func (c *RewardClient) Delete() *RewardDelete {
	mutation := newRewardMutation(c.config, OpDelete)
	return &RewardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RewardClient) DeleteOne(r *Reward) *RewardDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RewardClient) DeleteOneID(id uint64) *RewardDeleteOne {
	builder := c.Delete().Where(reward.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RewardDeleteOne{builder}
}

// Query returns a query builder for Reward.
func (c *RewardClient) Query() *RewardQuery {
	return &RewardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReward},
		inters: c.Interceptors(),
	}
}

// Get returns a Reward entity by its id.
func (c *RewardClient) Get(ctx context.Context, id uint64) (*Reward, error) {
	return c.Query().Where(reward.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RewardClient) GetX(ctx context.Context, id uint64) *Reward {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RewardClient) Hooks() []Hook {
	return c.hooks.Reward
}

// Interceptors returns the client interceptors.
func (c *RewardClient) Interceptors() []Interceptor {
	return c.inters.Reward
}

func (c *RewardClient) mutate(ctx context.Context, m *RewardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RewardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RewardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RewardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Reward mutation op: %q", m.Op())
	}
}

// RoundClient is a client for the Round schema.
type RoundClient struct {
	config
}

// NewRoundClient returns a client for the Round from the given config.
func NewRoundClient(c config) *RoundClient {
	return &RoundClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `round.Hooks(f(g(h())))`.
func (c *RoundClient) Use(hooks ...Hook) {
	c.hooks.Round = append(c.hooks.Round, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `round.Intercept(f(g(h())))`.
func (c *RoundClient) Intercept(interceptors ...Interceptor) {
	c.inters.Round = append(c.inters.Round, interceptors...)
}

// Create returns a builder for creating a Round entity.
func (c *RoundClient) Create() *RoundCreate {
	mutation := newRoundMutation(c.config, OpCreate)
	return &RoundCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Round entities.
func (c *RoundClient) CreateBulk(builders ...*RoundCreate) *RoundCreateBulk {
	return &RoundCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoundClient) MapCreateBulk(slice any, setFunc func(*RoundCreate, int)) *RoundCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoundCreateBulk{err: fmt.Errorf("calling to RoundClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoundCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoundCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Round.
func (c *RoundClient) Update() *RoundUpdate {
	mutation := newRoundMutation(c.config, OpUpdate)
	return &RoundUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoundClient) UpdateOne(r *Round) *RoundUpdateOne {
	mutation := newRoundMutation(c.config, OpUpdateOne, withRound(r))
	return &RoundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoundClient) UpdateOneID(id uint64) *RoundUpdateOne {
	mutation := newRoundMutation(c.config, OpUpdateOne, withRoundID(id))
	return &RoundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Round.
func (c *RoundClient) Delete() *RoundDelete {
	mutation := newRoundMutation(c.config, OpDelete)
	return &RoundDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoundClient) DeleteOne(r *Round) *RoundDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoundClient) DeleteOneID(id uint64) *RoundDeleteOne {
	builder := c.Delete().Where(round.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoundDeleteOne{builder}
}

// Query returns a query builder for Round.
func (c *RoundClient) Query() *RoundQuery {
	return &RoundQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRound},
		inters: c.Interceptors(),
	}
}

// Get returns a Round entity by its id.
func (c *RoundClient) Get(ctx context.Context, id uint64) (*Round, error) {
	return c.Query().Where(round.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoundClient) GetX(ctx context.Context, id uint64) *Round {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFold queries the fold edge of a Round.
func (c *RoundClient) QueryFold(r *Round) *RoundLambFoldQuery {
	query := (&RoundLambFoldClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(round.Table, round.FieldID, id),
			sqlgraph.To(roundlambfold.Table, roundlambfold.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, round.FoldTable, round.FoldColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvest queries the invest edge of a Round.
func (c *RoundClient) QueryInvest(r *Round) *RoundInvestQuery {
	query := (&RoundInvestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(round.Table, round.FieldID, id),
			sqlgraph.To(roundinvest.Table, roundinvest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, round.InvestTable, round.InvestColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoundClient) Hooks() []Hook {
	return c.hooks.Round
}

// Interceptors returns the client interceptors.
func (c *RoundClient) Interceptors() []Interceptor {
	return c.inters.Round
}

func (c *RoundClient) mutate(ctx context.Context, m *RoundMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoundCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoundUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoundDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Round mutation op: %q", m.Op())
	}
}

// RoundInvestClient is a client for the RoundInvest schema.
type RoundInvestClient struct {
	config
}

// NewRoundInvestClient returns a client for the RoundInvest from the given config.
func NewRoundInvestClient(c config) *RoundInvestClient {
	return &RoundInvestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `roundinvest.Hooks(f(g(h())))`.
func (c *RoundInvestClient) Use(hooks ...Hook) {
	c.hooks.RoundInvest = append(c.hooks.RoundInvest, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `roundinvest.Intercept(f(g(h())))`.
func (c *RoundInvestClient) Intercept(interceptors ...Interceptor) {
	c.inters.RoundInvest = append(c.inters.RoundInvest, interceptors...)
}

// Create returns a builder for creating a RoundInvest entity.
func (c *RoundInvestClient) Create() *RoundInvestCreate {
	mutation := newRoundInvestMutation(c.config, OpCreate)
	return &RoundInvestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RoundInvest entities.
func (c *RoundInvestClient) CreateBulk(builders ...*RoundInvestCreate) *RoundInvestCreateBulk {
	return &RoundInvestCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoundInvestClient) MapCreateBulk(slice any, setFunc func(*RoundInvestCreate, int)) *RoundInvestCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoundInvestCreateBulk{err: fmt.Errorf("calling to RoundInvestClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoundInvestCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoundInvestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RoundInvest.
func (c *RoundInvestClient) Update() *RoundInvestUpdate {
	mutation := newRoundInvestMutation(c.config, OpUpdate)
	return &RoundInvestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoundInvestClient) UpdateOne(ri *RoundInvest) *RoundInvestUpdateOne {
	mutation := newRoundInvestMutation(c.config, OpUpdateOne, withRoundInvest(ri))
	return &RoundInvestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoundInvestClient) UpdateOneID(id uint64) *RoundInvestUpdateOne {
	mutation := newRoundInvestMutation(c.config, OpUpdateOne, withRoundInvestID(id))
	return &RoundInvestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RoundInvest.
func (c *RoundInvestClient) Delete() *RoundInvestDelete {
	mutation := newRoundInvestMutation(c.config, OpDelete)
	return &RoundInvestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoundInvestClient) DeleteOne(ri *RoundInvest) *RoundInvestDeleteOne {
	return c.DeleteOneID(ri.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoundInvestClient) DeleteOneID(id uint64) *RoundInvestDeleteOne {
	builder := c.Delete().Where(roundinvest.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoundInvestDeleteOne{builder}
}

// Query returns a query builder for RoundInvest.
func (c *RoundInvestClient) Query() *RoundInvestQuery {
	return &RoundInvestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRoundInvest},
		inters: c.Interceptors(),
	}
}

// Get returns a RoundInvest entity by its id.
func (c *RoundInvestClient) Get(ctx context.Context, id uint64) (*RoundInvest, error) {
	return c.Query().Where(roundinvest.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoundInvestClient) GetX(ctx context.Context, id uint64) *RoundInvest {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRound queries the round edge of a RoundInvest.
func (c *RoundInvestClient) QueryRound(ri *RoundInvest) *RoundQuery {
	query := (&RoundClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ri.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(roundinvest.Table, roundinvest.FieldID, id),
			sqlgraph.To(round.Table, round.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, roundinvest.RoundTable, roundinvest.RoundColumn),
		)
		fromV = sqlgraph.Neighbors(ri.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoundInvestClient) Hooks() []Hook {
	return c.hooks.RoundInvest
}

// Interceptors returns the client interceptors.
func (c *RoundInvestClient) Interceptors() []Interceptor {
	return c.inters.RoundInvest
}

func (c *RoundInvestClient) mutate(ctx context.Context, m *RoundInvestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoundInvestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoundInvestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoundInvestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoundInvestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RoundInvest mutation op: %q", m.Op())
	}
}

// RoundLambFoldClient is a client for the RoundLambFold schema.
type RoundLambFoldClient struct {
	config
}

// NewRoundLambFoldClient returns a client for the RoundLambFold from the given config.
func NewRoundLambFoldClient(c config) *RoundLambFoldClient {
	return &RoundLambFoldClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `roundlambfold.Hooks(f(g(h())))`.
func (c *RoundLambFoldClient) Use(hooks ...Hook) {
	c.hooks.RoundLambFold = append(c.hooks.RoundLambFold, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `roundlambfold.Intercept(f(g(h())))`.
func (c *RoundLambFoldClient) Intercept(interceptors ...Interceptor) {
	c.inters.RoundLambFold = append(c.inters.RoundLambFold, interceptors...)
}

// Create returns a builder for creating a RoundLambFold entity.
func (c *RoundLambFoldClient) Create() *RoundLambFoldCreate {
	mutation := newRoundLambFoldMutation(c.config, OpCreate)
	return &RoundLambFoldCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RoundLambFold entities.
func (c *RoundLambFoldClient) CreateBulk(builders ...*RoundLambFoldCreate) *RoundLambFoldCreateBulk {
	return &RoundLambFoldCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoundLambFoldClient) MapCreateBulk(slice any, setFunc func(*RoundLambFoldCreate, int)) *RoundLambFoldCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoundLambFoldCreateBulk{err: fmt.Errorf("calling to RoundLambFoldClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoundLambFoldCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoundLambFoldCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RoundLambFold.
func (c *RoundLambFoldClient) Update() *RoundLambFoldUpdate {
	mutation := newRoundLambFoldMutation(c.config, OpUpdate)
	return &RoundLambFoldUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoundLambFoldClient) UpdateOne(rlf *RoundLambFold) *RoundLambFoldUpdateOne {
	mutation := newRoundLambFoldMutation(c.config, OpUpdateOne, withRoundLambFold(rlf))
	return &RoundLambFoldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoundLambFoldClient) UpdateOneID(id uint64) *RoundLambFoldUpdateOne {
	mutation := newRoundLambFoldMutation(c.config, OpUpdateOne, withRoundLambFoldID(id))
	return &RoundLambFoldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RoundLambFold.
func (c *RoundLambFoldClient) Delete() *RoundLambFoldDelete {
	mutation := newRoundLambFoldMutation(c.config, OpDelete)
	return &RoundLambFoldDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoundLambFoldClient) DeleteOne(rlf *RoundLambFold) *RoundLambFoldDeleteOne {
	return c.DeleteOneID(rlf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoundLambFoldClient) DeleteOneID(id uint64) *RoundLambFoldDeleteOne {
	builder := c.Delete().Where(roundlambfold.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoundLambFoldDeleteOne{builder}
}

// Query returns a query builder for RoundLambFold.
func (c *RoundLambFoldClient) Query() *RoundLambFoldQuery {
	return &RoundLambFoldQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRoundLambFold},
		inters: c.Interceptors(),
	}
}

// Get returns a RoundLambFold entity by its id.
func (c *RoundLambFoldClient) Get(ctx context.Context, id uint64) (*RoundLambFold, error) {
	return c.Query().Where(roundlambfold.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoundLambFoldClient) GetX(ctx context.Context, id uint64) *RoundLambFold {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRound queries the round edge of a RoundLambFold.
func (c *RoundLambFoldClient) QueryRound(rlf *RoundLambFold) *RoundQuery {
	query := (&RoundClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rlf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(roundlambfold.Table, roundlambfold.FieldID, id),
			sqlgraph.To(round.Table, round.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, roundlambfold.RoundTable, roundlambfold.RoundColumn),
		)
		fromV = sqlgraph.Neighbors(rlf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoundLambFoldClient) Hooks() []Hook {
	return c.hooks.RoundLambFold
}

// Interceptors returns the client interceptors.
func (c *RoundLambFoldClient) Interceptors() []Interceptor {
	return c.inters.RoundLambFold
}

func (c *RoundLambFoldClient) mutate(ctx context.Context, m *RoundLambFoldMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoundLambFoldCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoundLambFoldUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoundLambFoldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoundLambFoldDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RoundLambFold mutation op: %q", m.Op())
	}
}

// SettingClient is a client for the Setting schema.
type SettingClient struct {
	config
}

// NewSettingClient returns a client for the Setting from the given config.
func NewSettingClient(c config) *SettingClient {
	return &SettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `setting.Hooks(f(g(h())))`.
func (c *SettingClient) Use(hooks ...Hook) {
	c.hooks.Setting = append(c.hooks.Setting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `setting.Intercept(f(g(h())))`.
func (c *SettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Setting = append(c.inters.Setting, interceptors...)
}

// Create returns a builder for creating a Setting entity.
func (c *SettingClient) Create() *SettingCreate {
	mutation := newSettingMutation(c.config, OpCreate)
	return &SettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Setting entities.
func (c *SettingClient) CreateBulk(builders ...*SettingCreate) *SettingCreateBulk {
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SettingClient) MapCreateBulk(slice any, setFunc func(*SettingCreate, int)) *SettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SettingCreateBulk{err: fmt.Errorf("calling to SettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Setting.
func (c *SettingClient) Update() *SettingUpdate {
	mutation := newSettingMutation(c.config, OpUpdate)
	return &SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SettingClient) UpdateOne(s *Setting) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSetting(s))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SettingClient) UpdateOneID(id uint64) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSettingID(id))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Setting.
func (c *SettingClient) Delete() *SettingDelete {
	mutation := newSettingMutation(c.config, OpDelete)
	return &SettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SettingClient) DeleteOne(s *Setting) *SettingDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SettingClient) DeleteOneID(id uint64) *SettingDeleteOne {
	builder := c.Delete().Where(setting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SettingDeleteOne{builder}
}

// Query returns a query builder for Setting.
func (c *SettingClient) Query() *SettingQuery {
	return &SettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a Setting entity by its id.
func (c *SettingClient) Get(ctx context.Context, id uint64) (*Setting, error) {
	return c.Query().Where(setting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SettingClient) GetX(ctx context.Context, id uint64) *Setting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SettingClient) Hooks() []Hook {
	return c.hooks.Setting
}

// Interceptors returns the client interceptors.
func (c *SettingClient) Interceptors() []Interceptor {
	return c.inters.Setting
}

func (c *SettingClient) mutate(ctx context.Context, m *SettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Setting mutation op: %q", m.Op())
	}
}

// StatementClient is a client for the Statement schema.
type StatementClient struct {
	config
}

// NewStatementClient returns a client for the Statement from the given config.
func NewStatementClient(c config) *StatementClient {
	return &StatementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `statement.Hooks(f(g(h())))`.
func (c *StatementClient) Use(hooks ...Hook) {
	c.hooks.Statement = append(c.hooks.Statement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `statement.Intercept(f(g(h())))`.
func (c *StatementClient) Intercept(interceptors ...Interceptor) {
	c.inters.Statement = append(c.inters.Statement, interceptors...)
}

// Create returns a builder for creating a Statement entity.
func (c *StatementClient) Create() *StatementCreate {
	mutation := newStatementMutation(c.config, OpCreate)
	return &StatementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Statement entities.
func (c *StatementClient) CreateBulk(builders ...*StatementCreate) *StatementCreateBulk {
	return &StatementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StatementClient) MapCreateBulk(slice any, setFunc func(*StatementCreate, int)) *StatementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StatementCreateBulk{err: fmt.Errorf("calling to StatementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StatementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StatementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Statement.
func (c *StatementClient) Update() *StatementUpdate {
	mutation := newStatementMutation(c.config, OpUpdate)
	return &StatementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StatementClient) UpdateOne(s *Statement) *StatementUpdateOne {
	mutation := newStatementMutation(c.config, OpUpdateOne, withStatement(s))
	return &StatementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StatementClient) UpdateOneID(id uint64) *StatementUpdateOne {
	mutation := newStatementMutation(c.config, OpUpdateOne, withStatementID(id))
	return &StatementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Statement.
func (c *StatementClient) Delete() *StatementDelete {
	mutation := newStatementMutation(c.config, OpDelete)
	return &StatementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StatementClient) DeleteOne(s *Statement) *StatementDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StatementClient) DeleteOneID(id uint64) *StatementDeleteOne {
	builder := c.Delete().Where(statement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StatementDeleteOne{builder}
}

// Query returns a query builder for Statement.
func (c *StatementClient) Query() *StatementQuery {
	return &StatementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStatement},
		inters: c.Interceptors(),
	}
}

// Get returns a Statement entity by its id.
func (c *StatementClient) Get(ctx context.Context, id uint64) (*Statement, error) {
	return c.Query().Where(statement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StatementClient) GetX(ctx context.Context, id uint64) *Statement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *StatementClient) Hooks() []Hook {
	return c.hooks.Statement
}

// Interceptors returns the client interceptors.
func (c *StatementClient) Interceptors() []Interceptor {
	return c.inters.Statement
}

func (c *StatementClient) mutate(ctx context.Context, m *StatementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StatementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StatementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StatementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StatementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Statement mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Banner, Exchange, File, Order, OriginInviteCode, Player, Reward, Round,
		RoundInvest, RoundLambFold, Setting, Statement []ent.Hook
	}
	inters struct {
		Banner, Exchange, File, Order, OriginInviteCode, Player, Reward, Round,
		RoundInvest, RoundLambFold, Setting, Statement []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
