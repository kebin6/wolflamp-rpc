// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	uuid "github.com/gofrs/uuid/v5"
	"github.com/kebin6/wolflamp-rpc/ent/banner"
	"github.com/kebin6/wolflamp-rpc/ent/exchange"
	"github.com/kebin6/wolflamp-rpc/ent/file"
	"github.com/kebin6/wolflamp-rpc/ent/order"
	"github.com/kebin6/wolflamp-rpc/ent/origininvitecode"
	"github.com/kebin6/wolflamp-rpc/ent/player"
	"github.com/kebin6/wolflamp-rpc/ent/predicate"
	"github.com/kebin6/wolflamp-rpc/ent/reward"
	"github.com/kebin6/wolflamp-rpc/ent/round"
	"github.com/kebin6/wolflamp-rpc/ent/roundinvest"
	"github.com/kebin6/wolflamp-rpc/ent/roundlambfold"
	"github.com/kebin6/wolflamp-rpc/ent/setting"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBanner           = "Banner"
	TypeExchange         = "Exchange"
	TypeFile             = "File"
	TypeOrder            = "Order"
	TypeOriginInviteCode = "OriginInviteCode"
	TypePlayer           = "Player"
	TypeReward           = "Reward"
	TypeRound            = "Round"
	TypeRoundInvest      = "RoundInvest"
	TypeRoundLambFold    = "RoundLambFold"
	TypeSetting          = "Setting"
)

// BannerMutation represents an operation that mutates the Banner nodes in the graph.
type BannerMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	status        *uint8
	addstatus     *int8
	endpoint      *string
	module        *string
	file_type     *uint8
	addfile_type  *int8
	_path         *string
	jump_url      *string
	clearedFields map[string]struct{}
	file          *uuid.UUID
	clearedfile   bool
	done          bool
	oldValue      func(context.Context) (*Banner, error)
	predicates    []predicate.Banner
}

var _ ent.Mutation = (*BannerMutation)(nil)

// bannerOption allows management of the mutation configuration using functional options.
type bannerOption func(*BannerMutation)

// newBannerMutation creates new mutation for the Banner entity.
func newBannerMutation(c config, op Op, opts ...bannerOption) *BannerMutation {
	m := &BannerMutation{
		config:        c,
		op:            op,
		typ:           TypeBanner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannerID sets the ID field of the mutation.
func withBannerID(id uint64) bannerOption {
	return func(m *BannerMutation) {
		var (
			err   error
			once  sync.Once
			value *Banner
		)
		m.oldValue = func(ctx context.Context) (*Banner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Banner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanner sets the old Banner of the mutation.
func withBanner(node *Banner) bannerOption {
	return func(m *BannerMutation) {
		m.oldValue = func(context.Context) (*Banner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Banner entities.
func (m *BannerMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannerMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BannerMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Banner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BannerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BannerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BannerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BannerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BannerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BannerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *BannerMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BannerMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *BannerMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BannerMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *BannerMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[banner.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *BannerMutation) StatusCleared() bool {
	_, ok := m.clearedFields[banner.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *BannerMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, banner.FieldStatus)
}

// SetEndpoint sets the "endpoint" field.
func (m *BannerMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *BannerMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *BannerMutation) ResetEndpoint() {
	m.endpoint = nil
}

// SetModule sets the "module" field.
func (m *BannerMutation) SetModule(s string) {
	m.module = &s
}

// Module returns the value of the "module" field in the mutation.
func (m *BannerMutation) Module() (r string, exists bool) {
	v := m.module
	if v == nil {
		return
	}
	return *v, true
}

// OldModule returns the old "module" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldModule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModule: %w", err)
	}
	return oldValue.Module, nil
}

// ResetModule resets all changes to the "module" field.
func (m *BannerMutation) ResetModule() {
	m.module = nil
}

// SetFileType sets the "file_type" field.
func (m *BannerMutation) SetFileType(u uint8) {
	m.file_type = &u
	m.addfile_type = nil
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *BannerMutation) FileType() (r uint8, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldFileType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// AddFileType adds u to the "file_type" field.
func (m *BannerMutation) AddFileType(u int8) {
	if m.addfile_type != nil {
		*m.addfile_type += u
	} else {
		m.addfile_type = &u
	}
}

// AddedFileType returns the value that was added to the "file_type" field in this mutation.
func (m *BannerMutation) AddedFileType() (r int8, exists bool) {
	v := m.addfile_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileType resets all changes to the "file_type" field.
func (m *BannerMutation) ResetFileType() {
	m.file_type = nil
	m.addfile_type = nil
}

// SetPath sets the "path" field.
func (m *BannerMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *BannerMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *BannerMutation) ResetPath() {
	m._path = nil
}

// SetJumpURL sets the "jump_url" field.
func (m *BannerMutation) SetJumpURL(s string) {
	m.jump_url = &s
}

// JumpURL returns the value of the "jump_url" field in the mutation.
func (m *BannerMutation) JumpURL() (r string, exists bool) {
	v := m.jump_url
	if v == nil {
		return
	}
	return *v, true
}

// OldJumpURL returns the old "jump_url" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldJumpURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJumpURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJumpURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJumpURL: %w", err)
	}
	return oldValue.JumpURL, nil
}

// ClearJumpURL clears the value of the "jump_url" field.
func (m *BannerMutation) ClearJumpURL() {
	m.jump_url = nil
	m.clearedFields[banner.FieldJumpURL] = struct{}{}
}

// JumpURLCleared returns if the "jump_url" field was cleared in this mutation.
func (m *BannerMutation) JumpURLCleared() bool {
	_, ok := m.clearedFields[banner.FieldJumpURL]
	return ok
}

// ResetJumpURL resets all changes to the "jump_url" field.
func (m *BannerMutation) ResetJumpURL() {
	m.jump_url = nil
	delete(m.clearedFields, banner.FieldJumpURL)
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *BannerMutation) SetFileID(id uuid.UUID) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *BannerMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *BannerMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *BannerMutation) FileID() (id uuid.UUID, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *BannerMutation) FileIDs() (ids []uuid.UUID) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *BannerMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the BannerMutation builder.
func (m *BannerMutation) Where(ps ...predicate.Banner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BannerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BannerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Banner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BannerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BannerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Banner).
func (m *BannerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannerMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, banner.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, banner.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, banner.FieldStatus)
	}
	if m.endpoint != nil {
		fields = append(fields, banner.FieldEndpoint)
	}
	if m.module != nil {
		fields = append(fields, banner.FieldModule)
	}
	if m.file_type != nil {
		fields = append(fields, banner.FieldFileType)
	}
	if m._path != nil {
		fields = append(fields, banner.FieldPath)
	}
	if m.jump_url != nil {
		fields = append(fields, banner.FieldJumpURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banner.FieldCreatedAt:
		return m.CreatedAt()
	case banner.FieldUpdatedAt:
		return m.UpdatedAt()
	case banner.FieldStatus:
		return m.Status()
	case banner.FieldEndpoint:
		return m.Endpoint()
	case banner.FieldModule:
		return m.Module()
	case banner.FieldFileType:
		return m.FileType()
	case banner.FieldPath:
		return m.Path()
	case banner.FieldJumpURL:
		return m.JumpURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case banner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case banner.FieldStatus:
		return m.OldStatus(ctx)
	case banner.FieldEndpoint:
		return m.OldEndpoint(ctx)
	case banner.FieldModule:
		return m.OldModule(ctx)
	case banner.FieldFileType:
		return m.OldFileType(ctx)
	case banner.FieldPath:
		return m.OldPath(ctx)
	case banner.FieldJumpURL:
		return m.OldJumpURL(ctx)
	}
	return nil, fmt.Errorf("unknown Banner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case banner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case banner.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case banner.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	case banner.FieldModule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModule(v)
		return nil
	case banner.FieldFileType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case banner.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case banner.FieldJumpURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJumpURL(v)
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannerMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, banner.FieldStatus)
	}
	if m.addfile_type != nil {
		fields = append(fields, banner.FieldFileType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case banner.FieldStatus:
		return m.AddedStatus()
	case banner.FieldFileType:
		return m.AddedFileType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case banner.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case banner.FieldFileType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileType(v)
		return nil
	}
	return fmt.Errorf("unknown Banner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(banner.FieldStatus) {
		fields = append(fields, banner.FieldStatus)
	}
	if m.FieldCleared(banner.FieldJumpURL) {
		fields = append(fields, banner.FieldJumpURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannerMutation) ClearField(name string) error {
	switch name {
	case banner.FieldStatus:
		m.ClearStatus()
		return nil
	case banner.FieldJumpURL:
		m.ClearJumpURL()
		return nil
	}
	return fmt.Errorf("unknown Banner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannerMutation) ResetField(name string) error {
	switch name {
	case banner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case banner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case banner.FieldStatus:
		m.ResetStatus()
		return nil
	case banner.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	case banner.FieldModule:
		m.ResetModule()
		return nil
	case banner.FieldFileType:
		m.ResetFileType()
		return nil
	case banner.FieldPath:
		m.ResetPath()
		return nil
	case banner.FieldJumpURL:
		m.ResetJumpURL()
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.file != nil {
		edges = append(edges, banner.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case banner.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfile {
		edges = append(edges, banner.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannerMutation) EdgeCleared(name string) bool {
	switch name {
	case banner.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannerMutation) ClearEdge(name string) error {
	switch name {
	case banner.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown Banner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannerMutation) ResetEdge(name string) error {
	switch name {
	case banner.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown Banner edge %s", name)
}

// ExchangeMutation represents an operation that mutates the Exchange nodes in the graph.
type ExchangeMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	created_at     *time.Time
	updated_at     *time.Time
	status         *uint8
	addstatus      *int8
	player_id      *uint64
	addplayer_id   *int64
	transaction_id *string
	_type          *uint32
	add_type       *int32
	coin_num       *uint32
	addcoin_num    *int32
	lamp_num       *uint32
	addlamp_num    *int32
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Exchange, error)
	predicates     []predicate.Exchange
}

var _ ent.Mutation = (*ExchangeMutation)(nil)

// exchangeOption allows management of the mutation configuration using functional options.
type exchangeOption func(*ExchangeMutation)

// newExchangeMutation creates new mutation for the Exchange entity.
func newExchangeMutation(c config, op Op, opts ...exchangeOption) *ExchangeMutation {
	m := &ExchangeMutation{
		config:        c,
		op:            op,
		typ:           TypeExchange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExchangeID sets the ID field of the mutation.
func withExchangeID(id uint64) exchangeOption {
	return func(m *ExchangeMutation) {
		var (
			err   error
			once  sync.Once
			value *Exchange
		)
		m.oldValue = func(ctx context.Context) (*Exchange, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exchange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExchange sets the old Exchange of the mutation.
func withExchange(node *Exchange) exchangeOption {
	return func(m *ExchangeMutation) {
		m.oldValue = func(context.Context) (*Exchange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExchangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExchangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exchange entities.
func (m *ExchangeMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExchangeMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExchangeMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exchange.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ExchangeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExchangeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExchangeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExchangeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExchangeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExchangeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *ExchangeMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ExchangeMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *ExchangeMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ExchangeMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ExchangeMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[exchange.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ExchangeMutation) StatusCleared() bool {
	_, ok := m.clearedFields[exchange.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ExchangeMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, exchange.FieldStatus)
}

// SetPlayerID sets the "player_id" field.
func (m *ExchangeMutation) SetPlayerID(u uint64) {
	m.player_id = &u
	m.addplayer_id = nil
}

// PlayerID returns the value of the "player_id" field in the mutation.
func (m *ExchangeMutation) PlayerID() (r uint64, exists bool) {
	v := m.player_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayerID returns the old "player_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldPlayerID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayerID: %w", err)
	}
	return oldValue.PlayerID, nil
}

// AddPlayerID adds u to the "player_id" field.
func (m *ExchangeMutation) AddPlayerID(u int64) {
	if m.addplayer_id != nil {
		*m.addplayer_id += u
	} else {
		m.addplayer_id = &u
	}
}

// AddedPlayerID returns the value that was added to the "player_id" field in this mutation.
func (m *ExchangeMutation) AddedPlayerID() (r int64, exists bool) {
	v := m.addplayer_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlayerID resets all changes to the "player_id" field.
func (m *ExchangeMutation) ResetPlayerID() {
	m.player_id = nil
	m.addplayer_id = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *ExchangeMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *ExchangeMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *ExchangeMutation) ResetTransactionID() {
	m.transaction_id = nil
}

// SetType sets the "type" field.
func (m *ExchangeMutation) SetType(u uint32) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *ExchangeMutation) GetType() (r uint32, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldType(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *ExchangeMutation) AddType(u int32) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *ExchangeMutation) AddedType() (r int32, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *ExchangeMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetCoinNum sets the "coin_num" field.
func (m *ExchangeMutation) SetCoinNum(u uint32) {
	m.coin_num = &u
	m.addcoin_num = nil
}

// CoinNum returns the value of the "coin_num" field in the mutation.
func (m *ExchangeMutation) CoinNum() (r uint32, exists bool) {
	v := m.coin_num
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinNum returns the old "coin_num" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCoinNum(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinNum: %w", err)
	}
	return oldValue.CoinNum, nil
}

// AddCoinNum adds u to the "coin_num" field.
func (m *ExchangeMutation) AddCoinNum(u int32) {
	if m.addcoin_num != nil {
		*m.addcoin_num += u
	} else {
		m.addcoin_num = &u
	}
}

// AddedCoinNum returns the value that was added to the "coin_num" field in this mutation.
func (m *ExchangeMutation) AddedCoinNum() (r int32, exists bool) {
	v := m.addcoin_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoinNum resets all changes to the "coin_num" field.
func (m *ExchangeMutation) ResetCoinNum() {
	m.coin_num = nil
	m.addcoin_num = nil
}

// SetLampNum sets the "lamp_num" field.
func (m *ExchangeMutation) SetLampNum(u uint32) {
	m.lamp_num = &u
	m.addlamp_num = nil
}

// LampNum returns the value of the "lamp_num" field in the mutation.
func (m *ExchangeMutation) LampNum() (r uint32, exists bool) {
	v := m.lamp_num
	if v == nil {
		return
	}
	return *v, true
}

// OldLampNum returns the old "lamp_num" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldLampNum(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLampNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLampNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLampNum: %w", err)
	}
	return oldValue.LampNum, nil
}

// AddLampNum adds u to the "lamp_num" field.
func (m *ExchangeMutation) AddLampNum(u int32) {
	if m.addlamp_num != nil {
		*m.addlamp_num += u
	} else {
		m.addlamp_num = &u
	}
}

// AddedLampNum returns the value that was added to the "lamp_num" field in this mutation.
func (m *ExchangeMutation) AddedLampNum() (r int32, exists bool) {
	v := m.addlamp_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetLampNum resets all changes to the "lamp_num" field.
func (m *ExchangeMutation) ResetLampNum() {
	m.lamp_num = nil
	m.addlamp_num = nil
}

// Where appends a list predicates to the ExchangeMutation builder.
func (m *ExchangeMutation) Where(ps ...predicate.Exchange) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExchangeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExchangeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exchange, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExchangeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExchangeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exchange).
func (m *ExchangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExchangeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, exchange.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, exchange.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, exchange.FieldStatus)
	}
	if m.player_id != nil {
		fields = append(fields, exchange.FieldPlayerID)
	}
	if m.transaction_id != nil {
		fields = append(fields, exchange.FieldTransactionID)
	}
	if m._type != nil {
		fields = append(fields, exchange.FieldType)
	}
	if m.coin_num != nil {
		fields = append(fields, exchange.FieldCoinNum)
	}
	if m.lamp_num != nil {
		fields = append(fields, exchange.FieldLampNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExchangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exchange.FieldCreatedAt:
		return m.CreatedAt()
	case exchange.FieldUpdatedAt:
		return m.UpdatedAt()
	case exchange.FieldStatus:
		return m.Status()
	case exchange.FieldPlayerID:
		return m.PlayerID()
	case exchange.FieldTransactionID:
		return m.TransactionID()
	case exchange.FieldType:
		return m.GetType()
	case exchange.FieldCoinNum:
		return m.CoinNum()
	case exchange.FieldLampNum:
		return m.LampNum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExchangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exchange.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case exchange.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case exchange.FieldStatus:
		return m.OldStatus(ctx)
	case exchange.FieldPlayerID:
		return m.OldPlayerID(ctx)
	case exchange.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case exchange.FieldType:
		return m.OldType(ctx)
	case exchange.FieldCoinNum:
		return m.OldCoinNum(ctx)
	case exchange.FieldLampNum:
		return m.OldLampNum(ctx)
	}
	return nil, fmt.Errorf("unknown Exchange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exchange.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case exchange.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case exchange.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case exchange.FieldPlayerID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayerID(v)
		return nil
	case exchange.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case exchange.FieldType:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case exchange.FieldCoinNum:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinNum(v)
		return nil
	case exchange.FieldLampNum:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLampNum(v)
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExchangeMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, exchange.FieldStatus)
	}
	if m.addplayer_id != nil {
		fields = append(fields, exchange.FieldPlayerID)
	}
	if m.add_type != nil {
		fields = append(fields, exchange.FieldType)
	}
	if m.addcoin_num != nil {
		fields = append(fields, exchange.FieldCoinNum)
	}
	if m.addlamp_num != nil {
		fields = append(fields, exchange.FieldLampNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExchangeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exchange.FieldStatus:
		return m.AddedStatus()
	case exchange.FieldPlayerID:
		return m.AddedPlayerID()
	case exchange.FieldType:
		return m.AddedType()
	case exchange.FieldCoinNum:
		return m.AddedCoinNum()
	case exchange.FieldLampNum:
		return m.AddedLampNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exchange.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case exchange.FieldPlayerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlayerID(v)
		return nil
	case exchange.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case exchange.FieldCoinNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoinNum(v)
		return nil
	case exchange.FieldLampNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLampNum(v)
		return nil
	}
	return fmt.Errorf("unknown Exchange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExchangeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exchange.FieldStatus) {
		fields = append(fields, exchange.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExchangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExchangeMutation) ClearField(name string) error {
	switch name {
	case exchange.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Exchange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExchangeMutation) ResetField(name string) error {
	switch name {
	case exchange.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case exchange.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case exchange.FieldStatus:
		m.ResetStatus()
		return nil
	case exchange.FieldPlayerID:
		m.ResetPlayerID()
		return nil
	case exchange.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case exchange.FieldType:
		m.ResetType()
		return nil
	case exchange.FieldCoinNum:
		m.ResetCoinNum()
		return nil
	case exchange.FieldLampNum:
		m.ResetLampNum()
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExchangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExchangeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExchangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExchangeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExchangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExchangeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExchangeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Exchange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExchangeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Exchange edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	status        *uint8
	addstatus     *int8
	name          *string
	file_type     *uint8
	addfile_type  *int8
	size          *uint64
	addsize       *int64
	_path         *string
	user_id       *string
	md5           *string
	clearedFields map[string]struct{}
	banner        *uint64
	clearedbanner bool
	done          bool
	oldValue      func(context.Context) (*File, error)
	predicates    []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id uuid.UUID) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *FileMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *FileMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *FileMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *FileMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *FileMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[file.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *FileMutation) StatusCleared() bool {
	_, ok := m.clearedFields[file.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *FileMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, file.FieldStatus)
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetFileType sets the "file_type" field.
func (m *FileMutation) SetFileType(u uint8) {
	m.file_type = &u
	m.addfile_type = nil
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *FileMutation) FileType() (r uint8, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFileType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// AddFileType adds u to the "file_type" field.
func (m *FileMutation) AddFileType(u int8) {
	if m.addfile_type != nil {
		*m.addfile_type += u
	} else {
		m.addfile_type = &u
	}
}

// AddedFileType returns the value that was added to the "file_type" field in this mutation.
func (m *FileMutation) AddedFileType() (r int8, exists bool) {
	v := m.addfile_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileType resets all changes to the "file_type" field.
func (m *FileMutation) ResetFileType() {
	m.file_type = nil
	m.addfile_type = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(u uint64) {
	m.size = &u
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r uint64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds u to the "size" field.
func (m *FileMutation) AddSize(u int64) {
	if m.addsize != nil {
		*m.addsize += u
	} else {
		m.addsize = &u
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetPath sets the "path" field.
func (m *FileMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FileMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FileMutation) ResetPath() {
	m._path = nil
}

// SetUserID sets the "user_id" field.
func (m *FileMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FileMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FileMutation) ResetUserID() {
	m.user_id = nil
}

// SetMd5 sets the "md5" field.
func (m *FileMutation) SetMd5(s string) {
	m.md5 = &s
}

// Md5 returns the value of the "md5" field in the mutation.
func (m *FileMutation) Md5() (r string, exists bool) {
	v := m.md5
	if v == nil {
		return
	}
	return *v, true
}

// OldMd5 returns the old "md5" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldMd5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMd5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMd5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMd5: %w", err)
	}
	return oldValue.Md5, nil
}

// ResetMd5 resets all changes to the "md5" field.
func (m *FileMutation) ResetMd5() {
	m.md5 = nil
}

// SetBannerID sets the "banner" edge to the Banner entity by id.
func (m *FileMutation) SetBannerID(id uint64) {
	m.banner = &id
}

// ClearBanner clears the "banner" edge to the Banner entity.
func (m *FileMutation) ClearBanner() {
	m.clearedbanner = true
}

// BannerCleared reports if the "banner" edge to the Banner entity was cleared.
func (m *FileMutation) BannerCleared() bool {
	return m.clearedbanner
}

// BannerID returns the "banner" edge ID in the mutation.
func (m *FileMutation) BannerID() (id uint64, exists bool) {
	if m.banner != nil {
		return *m.banner, true
	}
	return
}

// BannerIDs returns the "banner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BannerID instead. It exists only for internal usage by the builders.
func (m *FileMutation) BannerIDs() (ids []uint64) {
	if id := m.banner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBanner resets all changes to the "banner" edge.
func (m *FileMutation) ResetBanner() {
	m.banner = nil
	m.clearedbanner = false
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, file.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m.file_type != nil {
		fields = append(fields, file.FieldFileType)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m._path != nil {
		fields = append(fields, file.FieldPath)
	}
	if m.user_id != nil {
		fields = append(fields, file.FieldUserID)
	}
	if m.md5 != nil {
		fields = append(fields, file.FieldMd5)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldStatus:
		return m.Status()
	case file.FieldName:
		return m.Name()
	case file.FieldFileType:
		return m.FileType()
	case file.FieldSize:
		return m.Size()
	case file.FieldPath:
		return m.Path()
	case file.FieldUserID:
		return m.UserID()
	case file.FieldMd5:
		return m.Md5()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldStatus:
		return m.OldStatus(ctx)
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldFileType:
		return m.OldFileType(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldPath:
		return m.OldPath(ctx)
	case file.FieldUserID:
		return m.OldUserID(ctx)
	case file.FieldMd5:
		return m.OldMd5(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldFileType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case file.FieldSize:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case file.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case file.FieldMd5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMd5(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, file.FieldStatus)
	}
	if m.addfile_type != nil {
		fields = append(fields, file.FieldFileType)
	}
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldStatus:
		return m.AddedStatus()
	case file.FieldFileType:
		return m.AddedFileType()
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case file.FieldFileType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileType(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldStatus) {
		fields = append(fields, file.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldStatus:
		m.ResetStatus()
		return nil
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldFileType:
		m.ResetFileType()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldPath:
		m.ResetPath()
		return nil
	case file.FieldUserID:
		m.ResetUserID()
		return nil
	case file.FieldMd5:
		m.ResetMd5()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.banner != nil {
		edges = append(edges, file.EdgeBanner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeBanner:
		if id := m.banner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbanner {
		edges = append(edges, file.EdgeBanner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeBanner:
		return m.clearedbanner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeBanner:
		m.ClearBanner()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeBanner:
		m.ResetBanner()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	status          *uint8
	addstatus       *int8
	player_id       *uint64
	addplayer_id    *int64
	_type           *string
	code            *string
	transaction_id  *string
	from_address    *string
	to_address      *string
	num             *float64
	addnum          *float64
	handling_fee    *float64
	addhandling_fee *float64
	network         *string
	remark          *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Order, error)
	predicates      []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id uint64) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *OrderMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OrderMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[order.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OrderMutation) StatusCleared() bool {
	_, ok := m.clearedFields[order.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, order.FieldStatus)
}

// SetPlayerID sets the "player_id" field.
func (m *OrderMutation) SetPlayerID(u uint64) {
	m.player_id = &u
	m.addplayer_id = nil
}

// PlayerID returns the value of the "player_id" field in the mutation.
func (m *OrderMutation) PlayerID() (r uint64, exists bool) {
	v := m.player_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayerID returns the old "player_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPlayerID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayerID: %w", err)
	}
	return oldValue.PlayerID, nil
}

// AddPlayerID adds u to the "player_id" field.
func (m *OrderMutation) AddPlayerID(u int64) {
	if m.addplayer_id != nil {
		*m.addplayer_id += u
	} else {
		m.addplayer_id = &u
	}
}

// AddedPlayerID returns the value that was added to the "player_id" field in this mutation.
func (m *OrderMutation) AddedPlayerID() (r int64, exists bool) {
	v := m.addplayer_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlayerID resets all changes to the "player_id" field.
func (m *OrderMutation) ResetPlayerID() {
	m.player_id = nil
	m.addplayer_id = nil
}

// SetType sets the "type" field.
func (m *OrderMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *OrderMutation) ResetType() {
	m._type = nil
}

// SetCode sets the "code" field.
func (m *OrderMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *OrderMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *OrderMutation) ResetCode() {
	m.code = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *OrderMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *OrderMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *OrderMutation) ResetTransactionID() {
	m.transaction_id = nil
}

// SetFromAddress sets the "from_address" field.
func (m *OrderMutation) SetFromAddress(s string) {
	m.from_address = &s
}

// FromAddress returns the value of the "from_address" field in the mutation.
func (m *OrderMutation) FromAddress() (r string, exists bool) {
	v := m.from_address
	if v == nil {
		return
	}
	return *v, true
}

// OldFromAddress returns the old "from_address" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldFromAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromAddress: %w", err)
	}
	return oldValue.FromAddress, nil
}

// ResetFromAddress resets all changes to the "from_address" field.
func (m *OrderMutation) ResetFromAddress() {
	m.from_address = nil
}

// SetToAddress sets the "to_address" field.
func (m *OrderMutation) SetToAddress(s string) {
	m.to_address = &s
}

// ToAddress returns the value of the "to_address" field in the mutation.
func (m *OrderMutation) ToAddress() (r string, exists bool) {
	v := m.to_address
	if v == nil {
		return
	}
	return *v, true
}

// OldToAddress returns the old "to_address" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldToAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToAddress: %w", err)
	}
	return oldValue.ToAddress, nil
}

// ResetToAddress resets all changes to the "to_address" field.
func (m *OrderMutation) ResetToAddress() {
	m.to_address = nil
}

// SetNum sets the "num" field.
func (m *OrderMutation) SetNum(f float64) {
	m.num = &f
	m.addnum = nil
}

// Num returns the value of the "num" field in the mutation.
func (m *OrderMutation) Num() (r float64, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old "num" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNum(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds f to the "num" field.
func (m *OrderMutation) AddNum(f float64) {
	if m.addnum != nil {
		*m.addnum += f
	} else {
		m.addnum = &f
	}
}

// AddedNum returns the value that was added to the "num" field in this mutation.
func (m *OrderMutation) AddedNum() (r float64, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ResetNum resets all changes to the "num" field.
func (m *OrderMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
}

// SetHandlingFee sets the "handling_fee" field.
func (m *OrderMutation) SetHandlingFee(f float64) {
	m.handling_fee = &f
	m.addhandling_fee = nil
}

// HandlingFee returns the value of the "handling_fee" field in the mutation.
func (m *OrderMutation) HandlingFee() (r float64, exists bool) {
	v := m.handling_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlingFee returns the old "handling_fee" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldHandlingFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlingFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlingFee: %w", err)
	}
	return oldValue.HandlingFee, nil
}

// AddHandlingFee adds f to the "handling_fee" field.
func (m *OrderMutation) AddHandlingFee(f float64) {
	if m.addhandling_fee != nil {
		*m.addhandling_fee += f
	} else {
		m.addhandling_fee = &f
	}
}

// AddedHandlingFee returns the value that was added to the "handling_fee" field in this mutation.
func (m *OrderMutation) AddedHandlingFee() (r float64, exists bool) {
	v := m.addhandling_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetHandlingFee resets all changes to the "handling_fee" field.
func (m *OrderMutation) ResetHandlingFee() {
	m.handling_fee = nil
	m.addhandling_fee = nil
}

// SetNetwork sets the "network" field.
func (m *OrderMutation) SetNetwork(s string) {
	m.network = &s
}

// Network returns the value of the "network" field in the mutation.
func (m *OrderMutation) Network() (r string, exists bool) {
	v := m.network
	if v == nil {
		return
	}
	return *v, true
}

// OldNetwork returns the old "network" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNetwork(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetwork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetwork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetwork: %w", err)
	}
	return oldValue.Network, nil
}

// ResetNetwork resets all changes to the "network" field.
func (m *OrderMutation) ResetNetwork() {
	m.network = nil
}

// SetRemark sets the "remark" field.
func (m *OrderMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrderMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrderMutation) ResetRemark() {
	m.remark = nil
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.player_id != nil {
		fields = append(fields, order.FieldPlayerID)
	}
	if m._type != nil {
		fields = append(fields, order.FieldType)
	}
	if m.code != nil {
		fields = append(fields, order.FieldCode)
	}
	if m.transaction_id != nil {
		fields = append(fields, order.FieldTransactionID)
	}
	if m.from_address != nil {
		fields = append(fields, order.FieldFromAddress)
	}
	if m.to_address != nil {
		fields = append(fields, order.FieldToAddress)
	}
	if m.num != nil {
		fields = append(fields, order.FieldNum)
	}
	if m.handling_fee != nil {
		fields = append(fields, order.FieldHandlingFee)
	}
	if m.network != nil {
		fields = append(fields, order.FieldNetwork)
	}
	if m.remark != nil {
		fields = append(fields, order.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldStatus:
		return m.Status()
	case order.FieldPlayerID:
		return m.PlayerID()
	case order.FieldType:
		return m.GetType()
	case order.FieldCode:
		return m.Code()
	case order.FieldTransactionID:
		return m.TransactionID()
	case order.FieldFromAddress:
		return m.FromAddress()
	case order.FieldToAddress:
		return m.ToAddress()
	case order.FieldNum:
		return m.Num()
	case order.FieldHandlingFee:
		return m.HandlingFee()
	case order.FieldNetwork:
		return m.Network()
	case order.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldPlayerID:
		return m.OldPlayerID(ctx)
	case order.FieldType:
		return m.OldType(ctx)
	case order.FieldCode:
		return m.OldCode(ctx)
	case order.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case order.FieldFromAddress:
		return m.OldFromAddress(ctx)
	case order.FieldToAddress:
		return m.OldToAddress(ctx)
	case order.FieldNum:
		return m.OldNum(ctx)
	case order.FieldHandlingFee:
		return m.OldHandlingFee(ctx)
	case order.FieldNetwork:
		return m.OldNetwork(ctx)
	case order.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldPlayerID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayerID(v)
		return nil
	case order.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case order.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case order.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case order.FieldFromAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromAddress(v)
		return nil
	case order.FieldToAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToAddress(v)
		return nil
	case order.FieldNum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	case order.FieldHandlingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlingFee(v)
		return nil
	case order.FieldNetwork:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetwork(v)
		return nil
	case order.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.addplayer_id != nil {
		fields = append(fields, order.FieldPlayerID)
	}
	if m.addnum != nil {
		fields = append(fields, order.FieldNum)
	}
	if m.addhandling_fee != nil {
		fields = append(fields, order.FieldHandlingFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldStatus:
		return m.AddedStatus()
	case order.FieldPlayerID:
		return m.AddedPlayerID()
	case order.FieldNum:
		return m.AddedNum()
	case order.FieldHandlingFee:
		return m.AddedHandlingFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case order.FieldPlayerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlayerID(v)
		return nil
	case order.FieldNum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	case order.FieldHandlingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHandlingFee(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldStatus) {
		fields = append(fields, order.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldPlayerID:
		m.ResetPlayerID()
		return nil
	case order.FieldType:
		m.ResetType()
		return nil
	case order.FieldCode:
		m.ResetCode()
		return nil
	case order.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case order.FieldFromAddress:
		m.ResetFromAddress()
		return nil
	case order.FieldToAddress:
		m.ResetToAddress()
		return nil
	case order.FieldNum:
		m.ResetNum()
		return nil
	case order.FieldHandlingFee:
		m.ResetHandlingFee()
		return nil
	case order.FieldNetwork:
		m.ResetNetwork()
		return nil
	case order.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Order edge %s", name)
}

// OriginInviteCodeMutation represents an operation that mutates the OriginInviteCode nodes in the graph.
type OriginInviteCodeMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	status        *uint8
	addstatus     *int8
	code          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OriginInviteCode, error)
	predicates    []predicate.OriginInviteCode
}

var _ ent.Mutation = (*OriginInviteCodeMutation)(nil)

// origininvitecodeOption allows management of the mutation configuration using functional options.
type origininvitecodeOption func(*OriginInviteCodeMutation)

// newOriginInviteCodeMutation creates new mutation for the OriginInviteCode entity.
func newOriginInviteCodeMutation(c config, op Op, opts ...origininvitecodeOption) *OriginInviteCodeMutation {
	m := &OriginInviteCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeOriginInviteCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOriginInviteCodeID sets the ID field of the mutation.
func withOriginInviteCodeID(id uint64) origininvitecodeOption {
	return func(m *OriginInviteCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *OriginInviteCode
		)
		m.oldValue = func(ctx context.Context) (*OriginInviteCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OriginInviteCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOriginInviteCode sets the old OriginInviteCode of the mutation.
func withOriginInviteCode(node *OriginInviteCode) origininvitecodeOption {
	return func(m *OriginInviteCodeMutation) {
		m.oldValue = func(context.Context) (*OriginInviteCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OriginInviteCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OriginInviteCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OriginInviteCode entities.
func (m *OriginInviteCodeMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OriginInviteCodeMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OriginInviteCodeMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OriginInviteCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OriginInviteCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OriginInviteCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OriginInviteCode entity.
// If the OriginInviteCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OriginInviteCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OriginInviteCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OriginInviteCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OriginInviteCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OriginInviteCode entity.
// If the OriginInviteCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OriginInviteCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OriginInviteCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *OriginInviteCodeMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OriginInviteCodeMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OriginInviteCode entity.
// If the OriginInviteCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OriginInviteCodeMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *OriginInviteCodeMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OriginInviteCodeMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OriginInviteCodeMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[origininvitecode.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OriginInviteCodeMutation) StatusCleared() bool {
	_, ok := m.clearedFields[origininvitecode.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OriginInviteCodeMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, origininvitecode.FieldStatus)
}

// SetCode sets the "code" field.
func (m *OriginInviteCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *OriginInviteCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the OriginInviteCode entity.
// If the OriginInviteCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OriginInviteCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *OriginInviteCodeMutation) ResetCode() {
	m.code = nil
}

// Where appends a list predicates to the OriginInviteCodeMutation builder.
func (m *OriginInviteCodeMutation) Where(ps ...predicate.OriginInviteCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OriginInviteCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OriginInviteCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OriginInviteCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OriginInviteCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OriginInviteCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OriginInviteCode).
func (m *OriginInviteCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OriginInviteCodeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, origininvitecode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, origininvitecode.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, origininvitecode.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, origininvitecode.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OriginInviteCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case origininvitecode.FieldCreatedAt:
		return m.CreatedAt()
	case origininvitecode.FieldUpdatedAt:
		return m.UpdatedAt()
	case origininvitecode.FieldStatus:
		return m.Status()
	case origininvitecode.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OriginInviteCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case origininvitecode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case origininvitecode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case origininvitecode.FieldStatus:
		return m.OldStatus(ctx)
	case origininvitecode.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown OriginInviteCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OriginInviteCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case origininvitecode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case origininvitecode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case origininvitecode.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case origininvitecode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown OriginInviteCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OriginInviteCodeMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, origininvitecode.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OriginInviteCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case origininvitecode.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OriginInviteCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case origininvitecode.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OriginInviteCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OriginInviteCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(origininvitecode.FieldStatus) {
		fields = append(fields, origininvitecode.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OriginInviteCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OriginInviteCodeMutation) ClearField(name string) error {
	switch name {
	case origininvitecode.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown OriginInviteCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OriginInviteCodeMutation) ResetField(name string) error {
	switch name {
	case origininvitecode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case origininvitecode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case origininvitecode.FieldStatus:
		m.ResetStatus()
		return nil
	case origininvitecode.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown OriginInviteCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OriginInviteCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OriginInviteCodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OriginInviteCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OriginInviteCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OriginInviteCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OriginInviteCodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OriginInviteCodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OriginInviteCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OriginInviteCodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OriginInviteCode edge %s", name)
}

// PlayerMutation represents an operation that mutates the Player nodes in the graph.
type PlayerMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uint64
	created_at                *time.Time
	updated_at                *time.Time
	status                    *uint8
	addstatus                 *int8
	name                      *string
	email                     *string
	password                  *string
	transaction_password      *string
	lamp                      *float32
	addlamp                   *float32
	rank                      *uint32
	addrank                   *int32
	amount                    *float64
	addamount                 *float64
	deposit_address           *string
	invited_num               *uint32
	addinvited_num            *int32
	total_income              *float64
	addtotal_income           *float64
	profit_and_loss           *float32
	addprofit_and_loss        *float32
	recent_100_win_percent    *float32
	addrecent_100_win_percent *float32
	invite_code               *string
	invited_code              *string
	system_commission         *float32
	addsystem_commission      *float32
	clearedFields             map[string]struct{}
	inviter                   *uint64
	clearedinviter            bool
	invitees                  map[uint64]struct{}
	removedinvitees           map[uint64]struct{}
	clearedinvitees           bool
	done                      bool
	oldValue                  func(context.Context) (*Player, error)
	predicates                []predicate.Player
}

var _ ent.Mutation = (*PlayerMutation)(nil)

// playerOption allows management of the mutation configuration using functional options.
type playerOption func(*PlayerMutation)

// newPlayerMutation creates new mutation for the Player entity.
func newPlayerMutation(c config, op Op, opts ...playerOption) *PlayerMutation {
	m := &PlayerMutation{
		config:        c,
		op:            op,
		typ:           TypePlayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlayerID sets the ID field of the mutation.
func withPlayerID(id uint64) playerOption {
	return func(m *PlayerMutation) {
		var (
			err   error
			once  sync.Once
			value *Player
		)
		m.oldValue = func(ctx context.Context) (*Player, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Player.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayer sets the old Player of the mutation.
func withPlayer(node *Player) playerOption {
	return func(m *PlayerMutation) {
		m.oldValue = func(context.Context) (*Player, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Player entities.
func (m *PlayerMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlayerMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlayerMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Player.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PlayerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlayerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlayerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlayerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlayerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlayerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *PlayerMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PlayerMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *PlayerMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PlayerMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *PlayerMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[player.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PlayerMutation) StatusCleared() bool {
	_, ok := m.clearedFields[player.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PlayerMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, player.FieldStatus)
}

// SetName sets the "name" field.
func (m *PlayerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlayerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlayerMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *PlayerMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *PlayerMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *PlayerMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *PlayerMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *PlayerMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *PlayerMutation) ResetPassword() {
	m.password = nil
}

// SetTransactionPassword sets the "transaction_password" field.
func (m *PlayerMutation) SetTransactionPassword(s string) {
	m.transaction_password = &s
}

// TransactionPassword returns the value of the "transaction_password" field in the mutation.
func (m *PlayerMutation) TransactionPassword() (r string, exists bool) {
	v := m.transaction_password
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionPassword returns the old "transaction_password" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldTransactionPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionPassword: %w", err)
	}
	return oldValue.TransactionPassword, nil
}

// ResetTransactionPassword resets all changes to the "transaction_password" field.
func (m *PlayerMutation) ResetTransactionPassword() {
	m.transaction_password = nil
}

// SetLamp sets the "lamp" field.
func (m *PlayerMutation) SetLamp(f float32) {
	m.lamp = &f
	m.addlamp = nil
}

// Lamp returns the value of the "lamp" field in the mutation.
func (m *PlayerMutation) Lamp() (r float32, exists bool) {
	v := m.lamp
	if v == nil {
		return
	}
	return *v, true
}

// OldLamp returns the old "lamp" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldLamp(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLamp: %w", err)
	}
	return oldValue.Lamp, nil
}

// AddLamp adds f to the "lamp" field.
func (m *PlayerMutation) AddLamp(f float32) {
	if m.addlamp != nil {
		*m.addlamp += f
	} else {
		m.addlamp = &f
	}
}

// AddedLamp returns the value that was added to the "lamp" field in this mutation.
func (m *PlayerMutation) AddedLamp() (r float32, exists bool) {
	v := m.addlamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetLamp resets all changes to the "lamp" field.
func (m *PlayerMutation) ResetLamp() {
	m.lamp = nil
	m.addlamp = nil
}

// SetRank sets the "rank" field.
func (m *PlayerMutation) SetRank(u uint32) {
	m.rank = &u
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *PlayerMutation) Rank() (r uint32, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldRank(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds u to the "rank" field.
func (m *PlayerMutation) AddRank(u int32) {
	if m.addrank != nil {
		*m.addrank += u
	} else {
		m.addrank = &u
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *PlayerMutation) AddedRank() (r int32, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank resets all changes to the "rank" field.
func (m *PlayerMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetAmount sets the "amount" field.
func (m *PlayerMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PlayerMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *PlayerMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PlayerMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PlayerMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetDepositAddress sets the "deposit_address" field.
func (m *PlayerMutation) SetDepositAddress(s string) {
	m.deposit_address = &s
}

// DepositAddress returns the value of the "deposit_address" field in the mutation.
func (m *PlayerMutation) DepositAddress() (r string, exists bool) {
	v := m.deposit_address
	if v == nil {
		return
	}
	return *v, true
}

// OldDepositAddress returns the old "deposit_address" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldDepositAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepositAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepositAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepositAddress: %w", err)
	}
	return oldValue.DepositAddress, nil
}

// ResetDepositAddress resets all changes to the "deposit_address" field.
func (m *PlayerMutation) ResetDepositAddress() {
	m.deposit_address = nil
}

// SetInvitedNum sets the "invited_num" field.
func (m *PlayerMutation) SetInvitedNum(u uint32) {
	m.invited_num = &u
	m.addinvited_num = nil
}

// InvitedNum returns the value of the "invited_num" field in the mutation.
func (m *PlayerMutation) InvitedNum() (r uint32, exists bool) {
	v := m.invited_num
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitedNum returns the old "invited_num" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldInvitedNum(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitedNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitedNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitedNum: %w", err)
	}
	return oldValue.InvitedNum, nil
}

// AddInvitedNum adds u to the "invited_num" field.
func (m *PlayerMutation) AddInvitedNum(u int32) {
	if m.addinvited_num != nil {
		*m.addinvited_num += u
	} else {
		m.addinvited_num = &u
	}
}

// AddedInvitedNum returns the value that was added to the "invited_num" field in this mutation.
func (m *PlayerMutation) AddedInvitedNum() (r int32, exists bool) {
	v := m.addinvited_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetInvitedNum resets all changes to the "invited_num" field.
func (m *PlayerMutation) ResetInvitedNum() {
	m.invited_num = nil
	m.addinvited_num = nil
}

// SetTotalIncome sets the "total_income" field.
func (m *PlayerMutation) SetTotalIncome(f float64) {
	m.total_income = &f
	m.addtotal_income = nil
}

// TotalIncome returns the value of the "total_income" field in the mutation.
func (m *PlayerMutation) TotalIncome() (r float64, exists bool) {
	v := m.total_income
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalIncome returns the old "total_income" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldTotalIncome(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalIncome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalIncome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalIncome: %w", err)
	}
	return oldValue.TotalIncome, nil
}

// AddTotalIncome adds f to the "total_income" field.
func (m *PlayerMutation) AddTotalIncome(f float64) {
	if m.addtotal_income != nil {
		*m.addtotal_income += f
	} else {
		m.addtotal_income = &f
	}
}

// AddedTotalIncome returns the value that was added to the "total_income" field in this mutation.
func (m *PlayerMutation) AddedTotalIncome() (r float64, exists bool) {
	v := m.addtotal_income
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalIncome resets all changes to the "total_income" field.
func (m *PlayerMutation) ResetTotalIncome() {
	m.total_income = nil
	m.addtotal_income = nil
}

// SetProfitAndLoss sets the "profit_and_loss" field.
func (m *PlayerMutation) SetProfitAndLoss(f float32) {
	m.profit_and_loss = &f
	m.addprofit_and_loss = nil
}

// ProfitAndLoss returns the value of the "profit_and_loss" field in the mutation.
func (m *PlayerMutation) ProfitAndLoss() (r float32, exists bool) {
	v := m.profit_and_loss
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitAndLoss returns the old "profit_and_loss" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldProfitAndLoss(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitAndLoss is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitAndLoss requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitAndLoss: %w", err)
	}
	return oldValue.ProfitAndLoss, nil
}

// AddProfitAndLoss adds f to the "profit_and_loss" field.
func (m *PlayerMutation) AddProfitAndLoss(f float32) {
	if m.addprofit_and_loss != nil {
		*m.addprofit_and_loss += f
	} else {
		m.addprofit_and_loss = &f
	}
}

// AddedProfitAndLoss returns the value that was added to the "profit_and_loss" field in this mutation.
func (m *PlayerMutation) AddedProfitAndLoss() (r float32, exists bool) {
	v := m.addprofit_and_loss
	if v == nil {
		return
	}
	return *v, true
}

// ResetProfitAndLoss resets all changes to the "profit_and_loss" field.
func (m *PlayerMutation) ResetProfitAndLoss() {
	m.profit_and_loss = nil
	m.addprofit_and_loss = nil
}

// SetRecent100WinPercent sets the "recent_100_win_percent" field.
func (m *PlayerMutation) SetRecent100WinPercent(f float32) {
	m.recent_100_win_percent = &f
	m.addrecent_100_win_percent = nil
}

// Recent100WinPercent returns the value of the "recent_100_win_percent" field in the mutation.
func (m *PlayerMutation) Recent100WinPercent() (r float32, exists bool) {
	v := m.recent_100_win_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldRecent100WinPercent returns the old "recent_100_win_percent" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldRecent100WinPercent(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecent100WinPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecent100WinPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecent100WinPercent: %w", err)
	}
	return oldValue.Recent100WinPercent, nil
}

// AddRecent100WinPercent adds f to the "recent_100_win_percent" field.
func (m *PlayerMutation) AddRecent100WinPercent(f float32) {
	if m.addrecent_100_win_percent != nil {
		*m.addrecent_100_win_percent += f
	} else {
		m.addrecent_100_win_percent = &f
	}
}

// AddedRecent100WinPercent returns the value that was added to the "recent_100_win_percent" field in this mutation.
func (m *PlayerMutation) AddedRecent100WinPercent() (r float32, exists bool) {
	v := m.addrecent_100_win_percent
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecent100WinPercent resets all changes to the "recent_100_win_percent" field.
func (m *PlayerMutation) ResetRecent100WinPercent() {
	m.recent_100_win_percent = nil
	m.addrecent_100_win_percent = nil
}

// SetInviteCode sets the "invite_code" field.
func (m *PlayerMutation) SetInviteCode(s string) {
	m.invite_code = &s
}

// InviteCode returns the value of the "invite_code" field in the mutation.
func (m *PlayerMutation) InviteCode() (r string, exists bool) {
	v := m.invite_code
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteCode returns the old "invite_code" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldInviteCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteCode: %w", err)
	}
	return oldValue.InviteCode, nil
}

// ResetInviteCode resets all changes to the "invite_code" field.
func (m *PlayerMutation) ResetInviteCode() {
	m.invite_code = nil
}

// SetInviterID sets the "inviter_id" field.
func (m *PlayerMutation) SetInviterID(u uint64) {
	m.inviter = &u
}

// InviterID returns the value of the "inviter_id" field in the mutation.
func (m *PlayerMutation) InviterID() (r uint64, exists bool) {
	v := m.inviter
	if v == nil {
		return
	}
	return *v, true
}

// OldInviterID returns the old "inviter_id" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldInviterID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviterID: %w", err)
	}
	return oldValue.InviterID, nil
}

// ClearInviterID clears the value of the "inviter_id" field.
func (m *PlayerMutation) ClearInviterID() {
	m.inviter = nil
	m.clearedFields[player.FieldInviterID] = struct{}{}
}

// InviterIDCleared returns if the "inviter_id" field was cleared in this mutation.
func (m *PlayerMutation) InviterIDCleared() bool {
	_, ok := m.clearedFields[player.FieldInviterID]
	return ok
}

// ResetInviterID resets all changes to the "inviter_id" field.
func (m *PlayerMutation) ResetInviterID() {
	m.inviter = nil
	delete(m.clearedFields, player.FieldInviterID)
}

// SetInvitedCode sets the "invited_code" field.
func (m *PlayerMutation) SetInvitedCode(s string) {
	m.invited_code = &s
}

// InvitedCode returns the value of the "invited_code" field in the mutation.
func (m *PlayerMutation) InvitedCode() (r string, exists bool) {
	v := m.invited_code
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitedCode returns the old "invited_code" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldInvitedCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitedCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitedCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitedCode: %w", err)
	}
	return oldValue.InvitedCode, nil
}

// ResetInvitedCode resets all changes to the "invited_code" field.
func (m *PlayerMutation) ResetInvitedCode() {
	m.invited_code = nil
}

// SetSystemCommission sets the "system_commission" field.
func (m *PlayerMutation) SetSystemCommission(f float32) {
	m.system_commission = &f
	m.addsystem_commission = nil
}

// SystemCommission returns the value of the "system_commission" field in the mutation.
func (m *PlayerMutation) SystemCommission() (r float32, exists bool) {
	v := m.system_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemCommission returns the old "system_commission" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldSystemCommission(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemCommission: %w", err)
	}
	return oldValue.SystemCommission, nil
}

// AddSystemCommission adds f to the "system_commission" field.
func (m *PlayerMutation) AddSystemCommission(f float32) {
	if m.addsystem_commission != nil {
		*m.addsystem_commission += f
	} else {
		m.addsystem_commission = &f
	}
}

// AddedSystemCommission returns the value that was added to the "system_commission" field in this mutation.
func (m *PlayerMutation) AddedSystemCommission() (r float32, exists bool) {
	v := m.addsystem_commission
	if v == nil {
		return
	}
	return *v, true
}

// ResetSystemCommission resets all changes to the "system_commission" field.
func (m *PlayerMutation) ResetSystemCommission() {
	m.system_commission = nil
	m.addsystem_commission = nil
}

// ClearInviter clears the "inviter" edge to the Player entity.
func (m *PlayerMutation) ClearInviter() {
	m.clearedinviter = true
	m.clearedFields[player.FieldInviterID] = struct{}{}
}

// InviterCleared reports if the "inviter" edge to the Player entity was cleared.
func (m *PlayerMutation) InviterCleared() bool {
	return m.InviterIDCleared() || m.clearedinviter
}

// InviterIDs returns the "inviter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InviterID instead. It exists only for internal usage by the builders.
func (m *PlayerMutation) InviterIDs() (ids []uint64) {
	if id := m.inviter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInviter resets all changes to the "inviter" edge.
func (m *PlayerMutation) ResetInviter() {
	m.inviter = nil
	m.clearedinviter = false
}

// AddInviteeIDs adds the "invitees" edge to the Player entity by ids.
func (m *PlayerMutation) AddInviteeIDs(ids ...uint64) {
	if m.invitees == nil {
		m.invitees = make(map[uint64]struct{})
	}
	for i := range ids {
		m.invitees[ids[i]] = struct{}{}
	}
}

// ClearInvitees clears the "invitees" edge to the Player entity.
func (m *PlayerMutation) ClearInvitees() {
	m.clearedinvitees = true
}

// InviteesCleared reports if the "invitees" edge to the Player entity was cleared.
func (m *PlayerMutation) InviteesCleared() bool {
	return m.clearedinvitees
}

// RemoveInviteeIDs removes the "invitees" edge to the Player entity by IDs.
func (m *PlayerMutation) RemoveInviteeIDs(ids ...uint64) {
	if m.removedinvitees == nil {
		m.removedinvitees = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.invitees, ids[i])
		m.removedinvitees[ids[i]] = struct{}{}
	}
}

// RemovedInvitees returns the removed IDs of the "invitees" edge to the Player entity.
func (m *PlayerMutation) RemovedInviteesIDs() (ids []uint64) {
	for id := range m.removedinvitees {
		ids = append(ids, id)
	}
	return
}

// InviteesIDs returns the "invitees" edge IDs in the mutation.
func (m *PlayerMutation) InviteesIDs() (ids []uint64) {
	for id := range m.invitees {
		ids = append(ids, id)
	}
	return
}

// ResetInvitees resets all changes to the "invitees" edge.
func (m *PlayerMutation) ResetInvitees() {
	m.invitees = nil
	m.clearedinvitees = false
	m.removedinvitees = nil
}

// Where appends a list predicates to the PlayerMutation builder.
func (m *PlayerMutation) Where(ps ...predicate.Player) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlayerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlayerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Player, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlayerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlayerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Player).
func (m *PlayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlayerMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, player.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, player.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, player.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, player.FieldName)
	}
	if m.email != nil {
		fields = append(fields, player.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, player.FieldPassword)
	}
	if m.transaction_password != nil {
		fields = append(fields, player.FieldTransactionPassword)
	}
	if m.lamp != nil {
		fields = append(fields, player.FieldLamp)
	}
	if m.rank != nil {
		fields = append(fields, player.FieldRank)
	}
	if m.amount != nil {
		fields = append(fields, player.FieldAmount)
	}
	if m.deposit_address != nil {
		fields = append(fields, player.FieldDepositAddress)
	}
	if m.invited_num != nil {
		fields = append(fields, player.FieldInvitedNum)
	}
	if m.total_income != nil {
		fields = append(fields, player.FieldTotalIncome)
	}
	if m.profit_and_loss != nil {
		fields = append(fields, player.FieldProfitAndLoss)
	}
	if m.recent_100_win_percent != nil {
		fields = append(fields, player.FieldRecent100WinPercent)
	}
	if m.invite_code != nil {
		fields = append(fields, player.FieldInviteCode)
	}
	if m.inviter != nil {
		fields = append(fields, player.FieldInviterID)
	}
	if m.invited_code != nil {
		fields = append(fields, player.FieldInvitedCode)
	}
	if m.system_commission != nil {
		fields = append(fields, player.FieldSystemCommission)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case player.FieldCreatedAt:
		return m.CreatedAt()
	case player.FieldUpdatedAt:
		return m.UpdatedAt()
	case player.FieldStatus:
		return m.Status()
	case player.FieldName:
		return m.Name()
	case player.FieldEmail:
		return m.Email()
	case player.FieldPassword:
		return m.Password()
	case player.FieldTransactionPassword:
		return m.TransactionPassword()
	case player.FieldLamp:
		return m.Lamp()
	case player.FieldRank:
		return m.Rank()
	case player.FieldAmount:
		return m.Amount()
	case player.FieldDepositAddress:
		return m.DepositAddress()
	case player.FieldInvitedNum:
		return m.InvitedNum()
	case player.FieldTotalIncome:
		return m.TotalIncome()
	case player.FieldProfitAndLoss:
		return m.ProfitAndLoss()
	case player.FieldRecent100WinPercent:
		return m.Recent100WinPercent()
	case player.FieldInviteCode:
		return m.InviteCode()
	case player.FieldInviterID:
		return m.InviterID()
	case player.FieldInvitedCode:
		return m.InvitedCode()
	case player.FieldSystemCommission:
		return m.SystemCommission()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case player.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case player.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case player.FieldStatus:
		return m.OldStatus(ctx)
	case player.FieldName:
		return m.OldName(ctx)
	case player.FieldEmail:
		return m.OldEmail(ctx)
	case player.FieldPassword:
		return m.OldPassword(ctx)
	case player.FieldTransactionPassword:
		return m.OldTransactionPassword(ctx)
	case player.FieldLamp:
		return m.OldLamp(ctx)
	case player.FieldRank:
		return m.OldRank(ctx)
	case player.FieldAmount:
		return m.OldAmount(ctx)
	case player.FieldDepositAddress:
		return m.OldDepositAddress(ctx)
	case player.FieldInvitedNum:
		return m.OldInvitedNum(ctx)
	case player.FieldTotalIncome:
		return m.OldTotalIncome(ctx)
	case player.FieldProfitAndLoss:
		return m.OldProfitAndLoss(ctx)
	case player.FieldRecent100WinPercent:
		return m.OldRecent100WinPercent(ctx)
	case player.FieldInviteCode:
		return m.OldInviteCode(ctx)
	case player.FieldInviterID:
		return m.OldInviterID(ctx)
	case player.FieldInvitedCode:
		return m.OldInvitedCode(ctx)
	case player.FieldSystemCommission:
		return m.OldSystemCommission(ctx)
	}
	return nil, fmt.Errorf("unknown Player field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case player.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case player.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case player.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case player.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case player.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case player.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case player.FieldTransactionPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionPassword(v)
		return nil
	case player.FieldLamp:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLamp(v)
		return nil
	case player.FieldRank:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case player.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case player.FieldDepositAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepositAddress(v)
		return nil
	case player.FieldInvitedNum:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitedNum(v)
		return nil
	case player.FieldTotalIncome:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalIncome(v)
		return nil
	case player.FieldProfitAndLoss:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitAndLoss(v)
		return nil
	case player.FieldRecent100WinPercent:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecent100WinPercent(v)
		return nil
	case player.FieldInviteCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteCode(v)
		return nil
	case player.FieldInviterID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviterID(v)
		return nil
	case player.FieldInvitedCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitedCode(v)
		return nil
	case player.FieldSystemCommission:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemCommission(v)
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlayerMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, player.FieldStatus)
	}
	if m.addlamp != nil {
		fields = append(fields, player.FieldLamp)
	}
	if m.addrank != nil {
		fields = append(fields, player.FieldRank)
	}
	if m.addamount != nil {
		fields = append(fields, player.FieldAmount)
	}
	if m.addinvited_num != nil {
		fields = append(fields, player.FieldInvitedNum)
	}
	if m.addtotal_income != nil {
		fields = append(fields, player.FieldTotalIncome)
	}
	if m.addprofit_and_loss != nil {
		fields = append(fields, player.FieldProfitAndLoss)
	}
	if m.addrecent_100_win_percent != nil {
		fields = append(fields, player.FieldRecent100WinPercent)
	}
	if m.addsystem_commission != nil {
		fields = append(fields, player.FieldSystemCommission)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlayerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case player.FieldStatus:
		return m.AddedStatus()
	case player.FieldLamp:
		return m.AddedLamp()
	case player.FieldRank:
		return m.AddedRank()
	case player.FieldAmount:
		return m.AddedAmount()
	case player.FieldInvitedNum:
		return m.AddedInvitedNum()
	case player.FieldTotalIncome:
		return m.AddedTotalIncome()
	case player.FieldProfitAndLoss:
		return m.AddedProfitAndLoss()
	case player.FieldRecent100WinPercent:
		return m.AddedRecent100WinPercent()
	case player.FieldSystemCommission:
		return m.AddedSystemCommission()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case player.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case player.FieldLamp:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLamp(v)
		return nil
	case player.FieldRank:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	case player.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case player.FieldInvitedNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvitedNum(v)
		return nil
	case player.FieldTotalIncome:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalIncome(v)
		return nil
	case player.FieldProfitAndLoss:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitAndLoss(v)
		return nil
	case player.FieldRecent100WinPercent:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecent100WinPercent(v)
		return nil
	case player.FieldSystemCommission:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSystemCommission(v)
		return nil
	}
	return fmt.Errorf("unknown Player numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlayerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(player.FieldStatus) {
		fields = append(fields, player.FieldStatus)
	}
	if m.FieldCleared(player.FieldInviterID) {
		fields = append(fields, player.FieldInviterID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlayerMutation) ClearField(name string) error {
	switch name {
	case player.FieldStatus:
		m.ClearStatus()
		return nil
	case player.FieldInviterID:
		m.ClearInviterID()
		return nil
	}
	return fmt.Errorf("unknown Player nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlayerMutation) ResetField(name string) error {
	switch name {
	case player.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case player.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case player.FieldStatus:
		m.ResetStatus()
		return nil
	case player.FieldName:
		m.ResetName()
		return nil
	case player.FieldEmail:
		m.ResetEmail()
		return nil
	case player.FieldPassword:
		m.ResetPassword()
		return nil
	case player.FieldTransactionPassword:
		m.ResetTransactionPassword()
		return nil
	case player.FieldLamp:
		m.ResetLamp()
		return nil
	case player.FieldRank:
		m.ResetRank()
		return nil
	case player.FieldAmount:
		m.ResetAmount()
		return nil
	case player.FieldDepositAddress:
		m.ResetDepositAddress()
		return nil
	case player.FieldInvitedNum:
		m.ResetInvitedNum()
		return nil
	case player.FieldTotalIncome:
		m.ResetTotalIncome()
		return nil
	case player.FieldProfitAndLoss:
		m.ResetProfitAndLoss()
		return nil
	case player.FieldRecent100WinPercent:
		m.ResetRecent100WinPercent()
		return nil
	case player.FieldInviteCode:
		m.ResetInviteCode()
		return nil
	case player.FieldInviterID:
		m.ResetInviterID()
		return nil
	case player.FieldInvitedCode:
		m.ResetInvitedCode()
		return nil
	case player.FieldSystemCommission:
		m.ResetSystemCommission()
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.inviter != nil {
		edges = append(edges, player.EdgeInviter)
	}
	if m.invitees != nil {
		edges = append(edges, player.EdgeInvitees)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlayerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case player.EdgeInviter:
		if id := m.inviter; id != nil {
			return []ent.Value{*id}
		}
	case player.EdgeInvitees:
		ids := make([]ent.Value, 0, len(m.invitees))
		for id := range m.invitees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedinvitees != nil {
		edges = append(edges, player.EdgeInvitees)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlayerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case player.EdgeInvitees:
		ids := make([]ent.Value, 0, len(m.removedinvitees))
		for id := range m.removedinvitees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinviter {
		edges = append(edges, player.EdgeInviter)
	}
	if m.clearedinvitees {
		edges = append(edges, player.EdgeInvitees)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlayerMutation) EdgeCleared(name string) bool {
	switch name {
	case player.EdgeInviter:
		return m.clearedinviter
	case player.EdgeInvitees:
		return m.clearedinvitees
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlayerMutation) ClearEdge(name string) error {
	switch name {
	case player.EdgeInviter:
		m.ClearInviter()
		return nil
	}
	return fmt.Errorf("unknown Player unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlayerMutation) ResetEdge(name string) error {
	switch name {
	case player.EdgeInviter:
		m.ResetInviter()
		return nil
	case player.EdgeInvitees:
		m.ResetInvitees()
		return nil
	}
	return fmt.Errorf("unknown Player edge %s", name)
}

// RewardMutation represents an operation that mutates the Reward nodes in the graph.
type RewardMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint64
	created_at           *time.Time
	updated_at           *time.Time
	status               *uint8
	addstatus            *int8
	to_id                *uint64
	addto_id             *int64
	contributor_id       *uint64
	addcontributor_id    *int64
	contributor_email    *string
	contributor_level    *uint32
	addcontributor_level *int32
	num                  *float32
	addnum               *float32
	formula              *string
	remark               *string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Reward, error)
	predicates           []predicate.Reward
}

var _ ent.Mutation = (*RewardMutation)(nil)

// rewardOption allows management of the mutation configuration using functional options.
type rewardOption func(*RewardMutation)

// newRewardMutation creates new mutation for the Reward entity.
func newRewardMutation(c config, op Op, opts ...rewardOption) *RewardMutation {
	m := &RewardMutation{
		config:        c,
		op:            op,
		typ:           TypeReward,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRewardID sets the ID field of the mutation.
func withRewardID(id uint64) rewardOption {
	return func(m *RewardMutation) {
		var (
			err   error
			once  sync.Once
			value *Reward
		)
		m.oldValue = func(ctx context.Context) (*Reward, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reward.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReward sets the old Reward of the mutation.
func withReward(node *Reward) rewardOption {
	return func(m *RewardMutation) {
		m.oldValue = func(context.Context) (*Reward, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RewardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RewardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Reward entities.
func (m *RewardMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RewardMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RewardMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Reward.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RewardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RewardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Reward entity.
// If the Reward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RewardMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RewardMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RewardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Reward entity.
// If the Reward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RewardMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *RewardMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RewardMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Reward entity.
// If the Reward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *RewardMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RewardMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *RewardMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[reward.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RewardMutation) StatusCleared() bool {
	_, ok := m.clearedFields[reward.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RewardMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, reward.FieldStatus)
}

// SetToID sets the "to_id" field.
func (m *RewardMutation) SetToID(u uint64) {
	m.to_id = &u
	m.addto_id = nil
}

// ToID returns the value of the "to_id" field in the mutation.
func (m *RewardMutation) ToID() (r uint64, exists bool) {
	v := m.to_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToID returns the old "to_id" field's value of the Reward entity.
// If the Reward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardMutation) OldToID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToID: %w", err)
	}
	return oldValue.ToID, nil
}

// AddToID adds u to the "to_id" field.
func (m *RewardMutation) AddToID(u int64) {
	if m.addto_id != nil {
		*m.addto_id += u
	} else {
		m.addto_id = &u
	}
}

// AddedToID returns the value that was added to the "to_id" field in this mutation.
func (m *RewardMutation) AddedToID() (r int64, exists bool) {
	v := m.addto_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetToID resets all changes to the "to_id" field.
func (m *RewardMutation) ResetToID() {
	m.to_id = nil
	m.addto_id = nil
}

// SetContributorID sets the "contributor_id" field.
func (m *RewardMutation) SetContributorID(u uint64) {
	m.contributor_id = &u
	m.addcontributor_id = nil
}

// ContributorID returns the value of the "contributor_id" field in the mutation.
func (m *RewardMutation) ContributorID() (r uint64, exists bool) {
	v := m.contributor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContributorID returns the old "contributor_id" field's value of the Reward entity.
// If the Reward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardMutation) OldContributorID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContributorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContributorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContributorID: %w", err)
	}
	return oldValue.ContributorID, nil
}

// AddContributorID adds u to the "contributor_id" field.
func (m *RewardMutation) AddContributorID(u int64) {
	if m.addcontributor_id != nil {
		*m.addcontributor_id += u
	} else {
		m.addcontributor_id = &u
	}
}

// AddedContributorID returns the value that was added to the "contributor_id" field in this mutation.
func (m *RewardMutation) AddedContributorID() (r int64, exists bool) {
	v := m.addcontributor_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetContributorID resets all changes to the "contributor_id" field.
func (m *RewardMutation) ResetContributorID() {
	m.contributor_id = nil
	m.addcontributor_id = nil
}

// SetContributorEmail sets the "contributor_email" field.
func (m *RewardMutation) SetContributorEmail(s string) {
	m.contributor_email = &s
}

// ContributorEmail returns the value of the "contributor_email" field in the mutation.
func (m *RewardMutation) ContributorEmail() (r string, exists bool) {
	v := m.contributor_email
	if v == nil {
		return
	}
	return *v, true
}

// OldContributorEmail returns the old "contributor_email" field's value of the Reward entity.
// If the Reward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardMutation) OldContributorEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContributorEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContributorEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContributorEmail: %w", err)
	}
	return oldValue.ContributorEmail, nil
}

// ResetContributorEmail resets all changes to the "contributor_email" field.
func (m *RewardMutation) ResetContributorEmail() {
	m.contributor_email = nil
}

// SetContributorLevel sets the "contributor_level" field.
func (m *RewardMutation) SetContributorLevel(u uint32) {
	m.contributor_level = &u
	m.addcontributor_level = nil
}

// ContributorLevel returns the value of the "contributor_level" field in the mutation.
func (m *RewardMutation) ContributorLevel() (r uint32, exists bool) {
	v := m.contributor_level
	if v == nil {
		return
	}
	return *v, true
}

// OldContributorLevel returns the old "contributor_level" field's value of the Reward entity.
// If the Reward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardMutation) OldContributorLevel(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContributorLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContributorLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContributorLevel: %w", err)
	}
	return oldValue.ContributorLevel, nil
}

// AddContributorLevel adds u to the "contributor_level" field.
func (m *RewardMutation) AddContributorLevel(u int32) {
	if m.addcontributor_level != nil {
		*m.addcontributor_level += u
	} else {
		m.addcontributor_level = &u
	}
}

// AddedContributorLevel returns the value that was added to the "contributor_level" field in this mutation.
func (m *RewardMutation) AddedContributorLevel() (r int32, exists bool) {
	v := m.addcontributor_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetContributorLevel resets all changes to the "contributor_level" field.
func (m *RewardMutation) ResetContributorLevel() {
	m.contributor_level = nil
	m.addcontributor_level = nil
}

// SetNum sets the "num" field.
func (m *RewardMutation) SetNum(f float32) {
	m.num = &f
	m.addnum = nil
}

// Num returns the value of the "num" field in the mutation.
func (m *RewardMutation) Num() (r float32, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old "num" field's value of the Reward entity.
// If the Reward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardMutation) OldNum(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds f to the "num" field.
func (m *RewardMutation) AddNum(f float32) {
	if m.addnum != nil {
		*m.addnum += f
	} else {
		m.addnum = &f
	}
}

// AddedNum returns the value that was added to the "num" field in this mutation.
func (m *RewardMutation) AddedNum() (r float32, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ResetNum resets all changes to the "num" field.
func (m *RewardMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
}

// SetFormula sets the "formula" field.
func (m *RewardMutation) SetFormula(s string) {
	m.formula = &s
}

// Formula returns the value of the "formula" field in the mutation.
func (m *RewardMutation) Formula() (r string, exists bool) {
	v := m.formula
	if v == nil {
		return
	}
	return *v, true
}

// OldFormula returns the old "formula" field's value of the Reward entity.
// If the Reward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardMutation) OldFormula(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormula is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormula requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormula: %w", err)
	}
	return oldValue.Formula, nil
}

// ResetFormula resets all changes to the "formula" field.
func (m *RewardMutation) ResetFormula() {
	m.formula = nil
}

// SetRemark sets the "remark" field.
func (m *RewardMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RewardMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Reward entity.
// If the Reward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *RewardMutation) ResetRemark() {
	m.remark = nil
}

// Where appends a list predicates to the RewardMutation builder.
func (m *RewardMutation) Where(ps ...predicate.Reward) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RewardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RewardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Reward, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RewardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RewardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Reward).
func (m *RewardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RewardMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, reward.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, reward.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, reward.FieldStatus)
	}
	if m.to_id != nil {
		fields = append(fields, reward.FieldToID)
	}
	if m.contributor_id != nil {
		fields = append(fields, reward.FieldContributorID)
	}
	if m.contributor_email != nil {
		fields = append(fields, reward.FieldContributorEmail)
	}
	if m.contributor_level != nil {
		fields = append(fields, reward.FieldContributorLevel)
	}
	if m.num != nil {
		fields = append(fields, reward.FieldNum)
	}
	if m.formula != nil {
		fields = append(fields, reward.FieldFormula)
	}
	if m.remark != nil {
		fields = append(fields, reward.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RewardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reward.FieldCreatedAt:
		return m.CreatedAt()
	case reward.FieldUpdatedAt:
		return m.UpdatedAt()
	case reward.FieldStatus:
		return m.Status()
	case reward.FieldToID:
		return m.ToID()
	case reward.FieldContributorID:
		return m.ContributorID()
	case reward.FieldContributorEmail:
		return m.ContributorEmail()
	case reward.FieldContributorLevel:
		return m.ContributorLevel()
	case reward.FieldNum:
		return m.Num()
	case reward.FieldFormula:
		return m.Formula()
	case reward.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RewardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reward.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case reward.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case reward.FieldStatus:
		return m.OldStatus(ctx)
	case reward.FieldToID:
		return m.OldToID(ctx)
	case reward.FieldContributorID:
		return m.OldContributorID(ctx)
	case reward.FieldContributorEmail:
		return m.OldContributorEmail(ctx)
	case reward.FieldContributorLevel:
		return m.OldContributorLevel(ctx)
	case reward.FieldNum:
		return m.OldNum(ctx)
	case reward.FieldFormula:
		return m.OldFormula(ctx)
	case reward.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Reward field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RewardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reward.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case reward.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case reward.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case reward.FieldToID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToID(v)
		return nil
	case reward.FieldContributorID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContributorID(v)
		return nil
	case reward.FieldContributorEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContributorEmail(v)
		return nil
	case reward.FieldContributorLevel:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContributorLevel(v)
		return nil
	case reward.FieldNum:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	case reward.FieldFormula:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormula(v)
		return nil
	case reward.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Reward field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RewardMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, reward.FieldStatus)
	}
	if m.addto_id != nil {
		fields = append(fields, reward.FieldToID)
	}
	if m.addcontributor_id != nil {
		fields = append(fields, reward.FieldContributorID)
	}
	if m.addcontributor_level != nil {
		fields = append(fields, reward.FieldContributorLevel)
	}
	if m.addnum != nil {
		fields = append(fields, reward.FieldNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RewardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reward.FieldStatus:
		return m.AddedStatus()
	case reward.FieldToID:
		return m.AddedToID()
	case reward.FieldContributorID:
		return m.AddedContributorID()
	case reward.FieldContributorLevel:
		return m.AddedContributorLevel()
	case reward.FieldNum:
		return m.AddedNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RewardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reward.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case reward.FieldToID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToID(v)
		return nil
	case reward.FieldContributorID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContributorID(v)
		return nil
	case reward.FieldContributorLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContributorLevel(v)
		return nil
	case reward.FieldNum:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	}
	return fmt.Errorf("unknown Reward numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RewardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reward.FieldStatus) {
		fields = append(fields, reward.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RewardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RewardMutation) ClearField(name string) error {
	switch name {
	case reward.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Reward nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RewardMutation) ResetField(name string) error {
	switch name {
	case reward.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case reward.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case reward.FieldStatus:
		m.ResetStatus()
		return nil
	case reward.FieldToID:
		m.ResetToID()
		return nil
	case reward.FieldContributorID:
		m.ResetContributorID()
		return nil
	case reward.FieldContributorEmail:
		m.ResetContributorEmail()
		return nil
	case reward.FieldContributorLevel:
		m.ResetContributorLevel()
		return nil
	case reward.FieldNum:
		m.ResetNum()
		return nil
	case reward.FieldFormula:
		m.ResetFormula()
		return nil
	case reward.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Reward field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RewardMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RewardMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RewardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RewardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RewardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RewardMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RewardMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Reward unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RewardMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Reward edge %s", name)
}

// RoundMutation represents an operation that mutates the Round nodes in the graph.
type RoundMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint64
	created_at           *time.Time
	updated_at           *time.Time
	status               *uint8
	addstatus            *int8
	round_count          *uint32
	addround_count       *int32
	total_round_count    *uint64
	addtotal_round_count *int64
	start_at             *time.Time
	open_at              *time.Time
	end_at               *time.Time
	selected_fold        *uint32
	addselected_fold     *int32
	clearedFields        map[string]struct{}
	fold                 map[uint64]struct{}
	removedfold          map[uint64]struct{}
	clearedfold          bool
	invest               map[uint64]struct{}
	removedinvest        map[uint64]struct{}
	clearedinvest        bool
	done                 bool
	oldValue             func(context.Context) (*Round, error)
	predicates           []predicate.Round
}

var _ ent.Mutation = (*RoundMutation)(nil)

// roundOption allows management of the mutation configuration using functional options.
type roundOption func(*RoundMutation)

// newRoundMutation creates new mutation for the Round entity.
func newRoundMutation(c config, op Op, opts ...roundOption) *RoundMutation {
	m := &RoundMutation{
		config:        c,
		op:            op,
		typ:           TypeRound,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoundID sets the ID field of the mutation.
func withRoundID(id uint64) roundOption {
	return func(m *RoundMutation) {
		var (
			err   error
			once  sync.Once
			value *Round
		)
		m.oldValue = func(ctx context.Context) (*Round, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Round.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRound sets the old Round of the mutation.
func withRound(node *Round) roundOption {
	return func(m *RoundMutation) {
		m.oldValue = func(context.Context) (*Round, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Round entities.
func (m *RoundMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoundMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoundMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Round.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoundMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoundMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoundMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoundMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoundMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoundMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *RoundMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RoundMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *RoundMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RoundMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *RoundMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[round.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RoundMutation) StatusCleared() bool {
	_, ok := m.clearedFields[round.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RoundMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, round.FieldStatus)
}

// SetRoundCount sets the "round_count" field.
func (m *RoundMutation) SetRoundCount(u uint32) {
	m.round_count = &u
	m.addround_count = nil
}

// RoundCount returns the value of the "round_count" field in the mutation.
func (m *RoundMutation) RoundCount() (r uint32, exists bool) {
	v := m.round_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundCount returns the old "round_count" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldRoundCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundCount: %w", err)
	}
	return oldValue.RoundCount, nil
}

// AddRoundCount adds u to the "round_count" field.
func (m *RoundMutation) AddRoundCount(u int32) {
	if m.addround_count != nil {
		*m.addround_count += u
	} else {
		m.addround_count = &u
	}
}

// AddedRoundCount returns the value that was added to the "round_count" field in this mutation.
func (m *RoundMutation) AddedRoundCount() (r int32, exists bool) {
	v := m.addround_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoundCount resets all changes to the "round_count" field.
func (m *RoundMutation) ResetRoundCount() {
	m.round_count = nil
	m.addround_count = nil
}

// SetTotalRoundCount sets the "total_round_count" field.
func (m *RoundMutation) SetTotalRoundCount(u uint64) {
	m.total_round_count = &u
	m.addtotal_round_count = nil
}

// TotalRoundCount returns the value of the "total_round_count" field in the mutation.
func (m *RoundMutation) TotalRoundCount() (r uint64, exists bool) {
	v := m.total_round_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRoundCount returns the old "total_round_count" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldTotalRoundCount(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRoundCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRoundCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRoundCount: %w", err)
	}
	return oldValue.TotalRoundCount, nil
}

// AddTotalRoundCount adds u to the "total_round_count" field.
func (m *RoundMutation) AddTotalRoundCount(u int64) {
	if m.addtotal_round_count != nil {
		*m.addtotal_round_count += u
	} else {
		m.addtotal_round_count = &u
	}
}

// AddedTotalRoundCount returns the value that was added to the "total_round_count" field in this mutation.
func (m *RoundMutation) AddedTotalRoundCount() (r int64, exists bool) {
	v := m.addtotal_round_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalRoundCount clears the value of the "total_round_count" field.
func (m *RoundMutation) ClearTotalRoundCount() {
	m.total_round_count = nil
	m.addtotal_round_count = nil
	m.clearedFields[round.FieldTotalRoundCount] = struct{}{}
}

// TotalRoundCountCleared returns if the "total_round_count" field was cleared in this mutation.
func (m *RoundMutation) TotalRoundCountCleared() bool {
	_, ok := m.clearedFields[round.FieldTotalRoundCount]
	return ok
}

// ResetTotalRoundCount resets all changes to the "total_round_count" field.
func (m *RoundMutation) ResetTotalRoundCount() {
	m.total_round_count = nil
	m.addtotal_round_count = nil
	delete(m.clearedFields, round.FieldTotalRoundCount)
}

// SetStartAt sets the "start_at" field.
func (m *RoundMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *RoundMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *RoundMutation) ResetStartAt() {
	m.start_at = nil
}

// SetOpenAt sets the "open_at" field.
func (m *RoundMutation) SetOpenAt(t time.Time) {
	m.open_at = &t
}

// OpenAt returns the value of the "open_at" field in the mutation.
func (m *RoundMutation) OpenAt() (r time.Time, exists bool) {
	v := m.open_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenAt returns the old "open_at" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldOpenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenAt: %w", err)
	}
	return oldValue.OpenAt, nil
}

// ResetOpenAt resets all changes to the "open_at" field.
func (m *RoundMutation) ResetOpenAt() {
	m.open_at = nil
}

// SetEndAt sets the "end_at" field.
func (m *RoundMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *RoundMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *RoundMutation) ResetEndAt() {
	m.end_at = nil
}

// SetSelectedFold sets the "selected_fold" field.
func (m *RoundMutation) SetSelectedFold(u uint32) {
	m.selected_fold = &u
	m.addselected_fold = nil
}

// SelectedFold returns the value of the "selected_fold" field in the mutation.
func (m *RoundMutation) SelectedFold() (r uint32, exists bool) {
	v := m.selected_fold
	if v == nil {
		return
	}
	return *v, true
}

// OldSelectedFold returns the old "selected_fold" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldSelectedFold(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelectedFold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelectedFold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelectedFold: %w", err)
	}
	return oldValue.SelectedFold, nil
}

// AddSelectedFold adds u to the "selected_fold" field.
func (m *RoundMutation) AddSelectedFold(u int32) {
	if m.addselected_fold != nil {
		*m.addselected_fold += u
	} else {
		m.addselected_fold = &u
	}
}

// AddedSelectedFold returns the value that was added to the "selected_fold" field in this mutation.
func (m *RoundMutation) AddedSelectedFold() (r int32, exists bool) {
	v := m.addselected_fold
	if v == nil {
		return
	}
	return *v, true
}

// ResetSelectedFold resets all changes to the "selected_fold" field.
func (m *RoundMutation) ResetSelectedFold() {
	m.selected_fold = nil
	m.addselected_fold = nil
}

// AddFoldIDs adds the "fold" edge to the RoundLambFold entity by ids.
func (m *RoundMutation) AddFoldIDs(ids ...uint64) {
	if m.fold == nil {
		m.fold = make(map[uint64]struct{})
	}
	for i := range ids {
		m.fold[ids[i]] = struct{}{}
	}
}

// ClearFold clears the "fold" edge to the RoundLambFold entity.
func (m *RoundMutation) ClearFold() {
	m.clearedfold = true
}

// FoldCleared reports if the "fold" edge to the RoundLambFold entity was cleared.
func (m *RoundMutation) FoldCleared() bool {
	return m.clearedfold
}

// RemoveFoldIDs removes the "fold" edge to the RoundLambFold entity by IDs.
func (m *RoundMutation) RemoveFoldIDs(ids ...uint64) {
	if m.removedfold == nil {
		m.removedfold = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.fold, ids[i])
		m.removedfold[ids[i]] = struct{}{}
	}
}

// RemovedFold returns the removed IDs of the "fold" edge to the RoundLambFold entity.
func (m *RoundMutation) RemovedFoldIDs() (ids []uint64) {
	for id := range m.removedfold {
		ids = append(ids, id)
	}
	return
}

// FoldIDs returns the "fold" edge IDs in the mutation.
func (m *RoundMutation) FoldIDs() (ids []uint64) {
	for id := range m.fold {
		ids = append(ids, id)
	}
	return
}

// ResetFold resets all changes to the "fold" edge.
func (m *RoundMutation) ResetFold() {
	m.fold = nil
	m.clearedfold = false
	m.removedfold = nil
}

// AddInvestIDs adds the "invest" edge to the RoundInvest entity by ids.
func (m *RoundMutation) AddInvestIDs(ids ...uint64) {
	if m.invest == nil {
		m.invest = make(map[uint64]struct{})
	}
	for i := range ids {
		m.invest[ids[i]] = struct{}{}
	}
}

// ClearInvest clears the "invest" edge to the RoundInvest entity.
func (m *RoundMutation) ClearInvest() {
	m.clearedinvest = true
}

// InvestCleared reports if the "invest" edge to the RoundInvest entity was cleared.
func (m *RoundMutation) InvestCleared() bool {
	return m.clearedinvest
}

// RemoveInvestIDs removes the "invest" edge to the RoundInvest entity by IDs.
func (m *RoundMutation) RemoveInvestIDs(ids ...uint64) {
	if m.removedinvest == nil {
		m.removedinvest = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.invest, ids[i])
		m.removedinvest[ids[i]] = struct{}{}
	}
}

// RemovedInvest returns the removed IDs of the "invest" edge to the RoundInvest entity.
func (m *RoundMutation) RemovedInvestIDs() (ids []uint64) {
	for id := range m.removedinvest {
		ids = append(ids, id)
	}
	return
}

// InvestIDs returns the "invest" edge IDs in the mutation.
func (m *RoundMutation) InvestIDs() (ids []uint64) {
	for id := range m.invest {
		ids = append(ids, id)
	}
	return
}

// ResetInvest resets all changes to the "invest" edge.
func (m *RoundMutation) ResetInvest() {
	m.invest = nil
	m.clearedinvest = false
	m.removedinvest = nil
}

// Where appends a list predicates to the RoundMutation builder.
func (m *RoundMutation) Where(ps ...predicate.Round) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoundMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoundMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Round, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoundMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoundMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Round).
func (m *RoundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoundMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, round.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, round.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, round.FieldStatus)
	}
	if m.round_count != nil {
		fields = append(fields, round.FieldRoundCount)
	}
	if m.total_round_count != nil {
		fields = append(fields, round.FieldTotalRoundCount)
	}
	if m.start_at != nil {
		fields = append(fields, round.FieldStartAt)
	}
	if m.open_at != nil {
		fields = append(fields, round.FieldOpenAt)
	}
	if m.end_at != nil {
		fields = append(fields, round.FieldEndAt)
	}
	if m.selected_fold != nil {
		fields = append(fields, round.FieldSelectedFold)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case round.FieldCreatedAt:
		return m.CreatedAt()
	case round.FieldUpdatedAt:
		return m.UpdatedAt()
	case round.FieldStatus:
		return m.Status()
	case round.FieldRoundCount:
		return m.RoundCount()
	case round.FieldTotalRoundCount:
		return m.TotalRoundCount()
	case round.FieldStartAt:
		return m.StartAt()
	case round.FieldOpenAt:
		return m.OpenAt()
	case round.FieldEndAt:
		return m.EndAt()
	case round.FieldSelectedFold:
		return m.SelectedFold()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case round.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case round.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case round.FieldStatus:
		return m.OldStatus(ctx)
	case round.FieldRoundCount:
		return m.OldRoundCount(ctx)
	case round.FieldTotalRoundCount:
		return m.OldTotalRoundCount(ctx)
	case round.FieldStartAt:
		return m.OldStartAt(ctx)
	case round.FieldOpenAt:
		return m.OldOpenAt(ctx)
	case round.FieldEndAt:
		return m.OldEndAt(ctx)
	case round.FieldSelectedFold:
		return m.OldSelectedFold(ctx)
	}
	return nil, fmt.Errorf("unknown Round field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case round.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case round.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case round.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case round.FieldRoundCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundCount(v)
		return nil
	case round.FieldTotalRoundCount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRoundCount(v)
		return nil
	case round.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case round.FieldOpenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenAt(v)
		return nil
	case round.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case round.FieldSelectedFold:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelectedFold(v)
		return nil
	}
	return fmt.Errorf("unknown Round field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoundMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, round.FieldStatus)
	}
	if m.addround_count != nil {
		fields = append(fields, round.FieldRoundCount)
	}
	if m.addtotal_round_count != nil {
		fields = append(fields, round.FieldTotalRoundCount)
	}
	if m.addselected_fold != nil {
		fields = append(fields, round.FieldSelectedFold)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoundMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case round.FieldStatus:
		return m.AddedStatus()
	case round.FieldRoundCount:
		return m.AddedRoundCount()
	case round.FieldTotalRoundCount:
		return m.AddedTotalRoundCount()
	case round.FieldSelectedFold:
		return m.AddedSelectedFold()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundMutation) AddField(name string, value ent.Value) error {
	switch name {
	case round.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case round.FieldRoundCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundCount(v)
		return nil
	case round.FieldTotalRoundCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRoundCount(v)
		return nil
	case round.FieldSelectedFold:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSelectedFold(v)
		return nil
	}
	return fmt.Errorf("unknown Round numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoundMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(round.FieldStatus) {
		fields = append(fields, round.FieldStatus)
	}
	if m.FieldCleared(round.FieldTotalRoundCount) {
		fields = append(fields, round.FieldTotalRoundCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoundMutation) ClearField(name string) error {
	switch name {
	case round.FieldStatus:
		m.ClearStatus()
		return nil
	case round.FieldTotalRoundCount:
		m.ClearTotalRoundCount()
		return nil
	}
	return fmt.Errorf("unknown Round nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoundMutation) ResetField(name string) error {
	switch name {
	case round.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case round.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case round.FieldStatus:
		m.ResetStatus()
		return nil
	case round.FieldRoundCount:
		m.ResetRoundCount()
		return nil
	case round.FieldTotalRoundCount:
		m.ResetTotalRoundCount()
		return nil
	case round.FieldStartAt:
		m.ResetStartAt()
		return nil
	case round.FieldOpenAt:
		m.ResetOpenAt()
		return nil
	case round.FieldEndAt:
		m.ResetEndAt()
		return nil
	case round.FieldSelectedFold:
		m.ResetSelectedFold()
		return nil
	}
	return fmt.Errorf("unknown Round field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoundMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.fold != nil {
		edges = append(edges, round.EdgeFold)
	}
	if m.invest != nil {
		edges = append(edges, round.EdgeInvest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoundMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case round.EdgeFold:
		ids := make([]ent.Value, 0, len(m.fold))
		for id := range m.fold {
			ids = append(ids, id)
		}
		return ids
	case round.EdgeInvest:
		ids := make([]ent.Value, 0, len(m.invest))
		for id := range m.invest {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfold != nil {
		edges = append(edges, round.EdgeFold)
	}
	if m.removedinvest != nil {
		edges = append(edges, round.EdgeInvest)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoundMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case round.EdgeFold:
		ids := make([]ent.Value, 0, len(m.removedfold))
		for id := range m.removedfold {
			ids = append(ids, id)
		}
		return ids
	case round.EdgeInvest:
		ids := make([]ent.Value, 0, len(m.removedinvest))
		for id := range m.removedinvest {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfold {
		edges = append(edges, round.EdgeFold)
	}
	if m.clearedinvest {
		edges = append(edges, round.EdgeInvest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoundMutation) EdgeCleared(name string) bool {
	switch name {
	case round.EdgeFold:
		return m.clearedfold
	case round.EdgeInvest:
		return m.clearedinvest
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoundMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Round unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoundMutation) ResetEdge(name string) error {
	switch name {
	case round.EdgeFold:
		m.ResetFold()
		return nil
	case round.EdgeInvest:
		m.ResetInvest()
		return nil
	}
	return fmt.Errorf("unknown Round edge %s", name)
}

// RoundInvestMutation represents an operation that mutates the RoundInvest nodes in the graph.
type RoundInvestMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint64
	created_at           *time.Time
	updated_at           *time.Time
	player_id            *uint64
	addplayer_id         *int64
	player_email         *string
	fold_no              *uint32
	addfold_no           *int32
	lamb_num             *uint32
	addlamb_num          *int32
	profit_and_loss      *float32
	addprofit_and_loss   *float32
	round_count          *uint32
	addround_count       *int32
	total_round_count    *uint64
	addtotal_round_count *int64
	clearedFields        map[string]struct{}
	round                *uint64
	clearedround         bool
	done                 bool
	oldValue             func(context.Context) (*RoundInvest, error)
	predicates           []predicate.RoundInvest
}

var _ ent.Mutation = (*RoundInvestMutation)(nil)

// roundinvestOption allows management of the mutation configuration using functional options.
type roundinvestOption func(*RoundInvestMutation)

// newRoundInvestMutation creates new mutation for the RoundInvest entity.
func newRoundInvestMutation(c config, op Op, opts ...roundinvestOption) *RoundInvestMutation {
	m := &RoundInvestMutation{
		config:        c,
		op:            op,
		typ:           TypeRoundInvest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoundInvestID sets the ID field of the mutation.
func withRoundInvestID(id uint64) roundinvestOption {
	return func(m *RoundInvestMutation) {
		var (
			err   error
			once  sync.Once
			value *RoundInvest
		)
		m.oldValue = func(ctx context.Context) (*RoundInvest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoundInvest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoundInvest sets the old RoundInvest of the mutation.
func withRoundInvest(node *RoundInvest) roundinvestOption {
	return func(m *RoundInvestMutation) {
		m.oldValue = func(context.Context) (*RoundInvest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoundInvestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoundInvestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RoundInvest entities.
func (m *RoundInvestMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoundInvestMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoundInvestMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoundInvest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoundInvestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoundInvestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RoundInvest entity.
// If the RoundInvest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundInvestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoundInvestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoundInvestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoundInvestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RoundInvest entity.
// If the RoundInvest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundInvestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoundInvestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPlayerID sets the "player_id" field.
func (m *RoundInvestMutation) SetPlayerID(u uint64) {
	m.player_id = &u
	m.addplayer_id = nil
}

// PlayerID returns the value of the "player_id" field in the mutation.
func (m *RoundInvestMutation) PlayerID() (r uint64, exists bool) {
	v := m.player_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayerID returns the old "player_id" field's value of the RoundInvest entity.
// If the RoundInvest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundInvestMutation) OldPlayerID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayerID: %w", err)
	}
	return oldValue.PlayerID, nil
}

// AddPlayerID adds u to the "player_id" field.
func (m *RoundInvestMutation) AddPlayerID(u int64) {
	if m.addplayer_id != nil {
		*m.addplayer_id += u
	} else {
		m.addplayer_id = &u
	}
}

// AddedPlayerID returns the value that was added to the "player_id" field in this mutation.
func (m *RoundInvestMutation) AddedPlayerID() (r int64, exists bool) {
	v := m.addplayer_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlayerID resets all changes to the "player_id" field.
func (m *RoundInvestMutation) ResetPlayerID() {
	m.player_id = nil
	m.addplayer_id = nil
}

// SetPlayerEmail sets the "player_email" field.
func (m *RoundInvestMutation) SetPlayerEmail(s string) {
	m.player_email = &s
}

// PlayerEmail returns the value of the "player_email" field in the mutation.
func (m *RoundInvestMutation) PlayerEmail() (r string, exists bool) {
	v := m.player_email
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayerEmail returns the old "player_email" field's value of the RoundInvest entity.
// If the RoundInvest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundInvestMutation) OldPlayerEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayerEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayerEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayerEmail: %w", err)
	}
	return oldValue.PlayerEmail, nil
}

// ResetPlayerEmail resets all changes to the "player_email" field.
func (m *RoundInvestMutation) ResetPlayerEmail() {
	m.player_email = nil
}

// SetFoldNo sets the "fold_no" field.
func (m *RoundInvestMutation) SetFoldNo(u uint32) {
	m.fold_no = &u
	m.addfold_no = nil
}

// FoldNo returns the value of the "fold_no" field in the mutation.
func (m *RoundInvestMutation) FoldNo() (r uint32, exists bool) {
	v := m.fold_no
	if v == nil {
		return
	}
	return *v, true
}

// OldFoldNo returns the old "fold_no" field's value of the RoundInvest entity.
// If the RoundInvest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundInvestMutation) OldFoldNo(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFoldNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFoldNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFoldNo: %w", err)
	}
	return oldValue.FoldNo, nil
}

// AddFoldNo adds u to the "fold_no" field.
func (m *RoundInvestMutation) AddFoldNo(u int32) {
	if m.addfold_no != nil {
		*m.addfold_no += u
	} else {
		m.addfold_no = &u
	}
}

// AddedFoldNo returns the value that was added to the "fold_no" field in this mutation.
func (m *RoundInvestMutation) AddedFoldNo() (r int32, exists bool) {
	v := m.addfold_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetFoldNo resets all changes to the "fold_no" field.
func (m *RoundInvestMutation) ResetFoldNo() {
	m.fold_no = nil
	m.addfold_no = nil
}

// SetLambNum sets the "lamb_num" field.
func (m *RoundInvestMutation) SetLambNum(u uint32) {
	m.lamb_num = &u
	m.addlamb_num = nil
}

// LambNum returns the value of the "lamb_num" field in the mutation.
func (m *RoundInvestMutation) LambNum() (r uint32, exists bool) {
	v := m.lamb_num
	if v == nil {
		return
	}
	return *v, true
}

// OldLambNum returns the old "lamb_num" field's value of the RoundInvest entity.
// If the RoundInvest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundInvestMutation) OldLambNum(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLambNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLambNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLambNum: %w", err)
	}
	return oldValue.LambNum, nil
}

// AddLambNum adds u to the "lamb_num" field.
func (m *RoundInvestMutation) AddLambNum(u int32) {
	if m.addlamb_num != nil {
		*m.addlamb_num += u
	} else {
		m.addlamb_num = &u
	}
}

// AddedLambNum returns the value that was added to the "lamb_num" field in this mutation.
func (m *RoundInvestMutation) AddedLambNum() (r int32, exists bool) {
	v := m.addlamb_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetLambNum resets all changes to the "lamb_num" field.
func (m *RoundInvestMutation) ResetLambNum() {
	m.lamb_num = nil
	m.addlamb_num = nil
}

// SetProfitAndLoss sets the "profit_and_loss" field.
func (m *RoundInvestMutation) SetProfitAndLoss(f float32) {
	m.profit_and_loss = &f
	m.addprofit_and_loss = nil
}

// ProfitAndLoss returns the value of the "profit_and_loss" field in the mutation.
func (m *RoundInvestMutation) ProfitAndLoss() (r float32, exists bool) {
	v := m.profit_and_loss
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitAndLoss returns the old "profit_and_loss" field's value of the RoundInvest entity.
// If the RoundInvest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundInvestMutation) OldProfitAndLoss(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitAndLoss is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitAndLoss requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitAndLoss: %w", err)
	}
	return oldValue.ProfitAndLoss, nil
}

// AddProfitAndLoss adds f to the "profit_and_loss" field.
func (m *RoundInvestMutation) AddProfitAndLoss(f float32) {
	if m.addprofit_and_loss != nil {
		*m.addprofit_and_loss += f
	} else {
		m.addprofit_and_loss = &f
	}
}

// AddedProfitAndLoss returns the value that was added to the "profit_and_loss" field in this mutation.
func (m *RoundInvestMutation) AddedProfitAndLoss() (r float32, exists bool) {
	v := m.addprofit_and_loss
	if v == nil {
		return
	}
	return *v, true
}

// ResetProfitAndLoss resets all changes to the "profit_and_loss" field.
func (m *RoundInvestMutation) ResetProfitAndLoss() {
	m.profit_and_loss = nil
	m.addprofit_and_loss = nil
}

// SetRoundID sets the "round_id" field.
func (m *RoundInvestMutation) SetRoundID(u uint64) {
	m.round = &u
}

// RoundID returns the value of the "round_id" field in the mutation.
func (m *RoundInvestMutation) RoundID() (r uint64, exists bool) {
	v := m.round
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundID returns the old "round_id" field's value of the RoundInvest entity.
// If the RoundInvest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundInvestMutation) OldRoundID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundID: %w", err)
	}
	return oldValue.RoundID, nil
}

// ClearRoundID clears the value of the "round_id" field.
func (m *RoundInvestMutation) ClearRoundID() {
	m.round = nil
	m.clearedFields[roundinvest.FieldRoundID] = struct{}{}
}

// RoundIDCleared returns if the "round_id" field was cleared in this mutation.
func (m *RoundInvestMutation) RoundIDCleared() bool {
	_, ok := m.clearedFields[roundinvest.FieldRoundID]
	return ok
}

// ResetRoundID resets all changes to the "round_id" field.
func (m *RoundInvestMutation) ResetRoundID() {
	m.round = nil
	delete(m.clearedFields, roundinvest.FieldRoundID)
}

// SetRoundCount sets the "round_count" field.
func (m *RoundInvestMutation) SetRoundCount(u uint32) {
	m.round_count = &u
	m.addround_count = nil
}

// RoundCount returns the value of the "round_count" field in the mutation.
func (m *RoundInvestMutation) RoundCount() (r uint32, exists bool) {
	v := m.round_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundCount returns the old "round_count" field's value of the RoundInvest entity.
// If the RoundInvest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundInvestMutation) OldRoundCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundCount: %w", err)
	}
	return oldValue.RoundCount, nil
}

// AddRoundCount adds u to the "round_count" field.
func (m *RoundInvestMutation) AddRoundCount(u int32) {
	if m.addround_count != nil {
		*m.addround_count += u
	} else {
		m.addround_count = &u
	}
}

// AddedRoundCount returns the value that was added to the "round_count" field in this mutation.
func (m *RoundInvestMutation) AddedRoundCount() (r int32, exists bool) {
	v := m.addround_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoundCount clears the value of the "round_count" field.
func (m *RoundInvestMutation) ClearRoundCount() {
	m.round_count = nil
	m.addround_count = nil
	m.clearedFields[roundinvest.FieldRoundCount] = struct{}{}
}

// RoundCountCleared returns if the "round_count" field was cleared in this mutation.
func (m *RoundInvestMutation) RoundCountCleared() bool {
	_, ok := m.clearedFields[roundinvest.FieldRoundCount]
	return ok
}

// ResetRoundCount resets all changes to the "round_count" field.
func (m *RoundInvestMutation) ResetRoundCount() {
	m.round_count = nil
	m.addround_count = nil
	delete(m.clearedFields, roundinvest.FieldRoundCount)
}

// SetTotalRoundCount sets the "total_round_count" field.
func (m *RoundInvestMutation) SetTotalRoundCount(u uint64) {
	m.total_round_count = &u
	m.addtotal_round_count = nil
}

// TotalRoundCount returns the value of the "total_round_count" field in the mutation.
func (m *RoundInvestMutation) TotalRoundCount() (r uint64, exists bool) {
	v := m.total_round_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRoundCount returns the old "total_round_count" field's value of the RoundInvest entity.
// If the RoundInvest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundInvestMutation) OldTotalRoundCount(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRoundCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRoundCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRoundCount: %w", err)
	}
	return oldValue.TotalRoundCount, nil
}

// AddTotalRoundCount adds u to the "total_round_count" field.
func (m *RoundInvestMutation) AddTotalRoundCount(u int64) {
	if m.addtotal_round_count != nil {
		*m.addtotal_round_count += u
	} else {
		m.addtotal_round_count = &u
	}
}

// AddedTotalRoundCount returns the value that was added to the "total_round_count" field in this mutation.
func (m *RoundInvestMutation) AddedTotalRoundCount() (r int64, exists bool) {
	v := m.addtotal_round_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalRoundCount clears the value of the "total_round_count" field.
func (m *RoundInvestMutation) ClearTotalRoundCount() {
	m.total_round_count = nil
	m.addtotal_round_count = nil
	m.clearedFields[roundinvest.FieldTotalRoundCount] = struct{}{}
}

// TotalRoundCountCleared returns if the "total_round_count" field was cleared in this mutation.
func (m *RoundInvestMutation) TotalRoundCountCleared() bool {
	_, ok := m.clearedFields[roundinvest.FieldTotalRoundCount]
	return ok
}

// ResetTotalRoundCount resets all changes to the "total_round_count" field.
func (m *RoundInvestMutation) ResetTotalRoundCount() {
	m.total_round_count = nil
	m.addtotal_round_count = nil
	delete(m.clearedFields, roundinvest.FieldTotalRoundCount)
}

// ClearRound clears the "round" edge to the Round entity.
func (m *RoundInvestMutation) ClearRound() {
	m.clearedround = true
	m.clearedFields[roundinvest.FieldRoundID] = struct{}{}
}

// RoundCleared reports if the "round" edge to the Round entity was cleared.
func (m *RoundInvestMutation) RoundCleared() bool {
	return m.RoundIDCleared() || m.clearedround
}

// RoundIDs returns the "round" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoundID instead. It exists only for internal usage by the builders.
func (m *RoundInvestMutation) RoundIDs() (ids []uint64) {
	if id := m.round; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRound resets all changes to the "round" edge.
func (m *RoundInvestMutation) ResetRound() {
	m.round = nil
	m.clearedround = false
}

// Where appends a list predicates to the RoundInvestMutation builder.
func (m *RoundInvestMutation) Where(ps ...predicate.RoundInvest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoundInvestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoundInvestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoundInvest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoundInvestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoundInvestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoundInvest).
func (m *RoundInvestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoundInvestMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, roundinvest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, roundinvest.FieldUpdatedAt)
	}
	if m.player_id != nil {
		fields = append(fields, roundinvest.FieldPlayerID)
	}
	if m.player_email != nil {
		fields = append(fields, roundinvest.FieldPlayerEmail)
	}
	if m.fold_no != nil {
		fields = append(fields, roundinvest.FieldFoldNo)
	}
	if m.lamb_num != nil {
		fields = append(fields, roundinvest.FieldLambNum)
	}
	if m.profit_and_loss != nil {
		fields = append(fields, roundinvest.FieldProfitAndLoss)
	}
	if m.round != nil {
		fields = append(fields, roundinvest.FieldRoundID)
	}
	if m.round_count != nil {
		fields = append(fields, roundinvest.FieldRoundCount)
	}
	if m.total_round_count != nil {
		fields = append(fields, roundinvest.FieldTotalRoundCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoundInvestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roundinvest.FieldCreatedAt:
		return m.CreatedAt()
	case roundinvest.FieldUpdatedAt:
		return m.UpdatedAt()
	case roundinvest.FieldPlayerID:
		return m.PlayerID()
	case roundinvest.FieldPlayerEmail:
		return m.PlayerEmail()
	case roundinvest.FieldFoldNo:
		return m.FoldNo()
	case roundinvest.FieldLambNum:
		return m.LambNum()
	case roundinvest.FieldProfitAndLoss:
		return m.ProfitAndLoss()
	case roundinvest.FieldRoundID:
		return m.RoundID()
	case roundinvest.FieldRoundCount:
		return m.RoundCount()
	case roundinvest.FieldTotalRoundCount:
		return m.TotalRoundCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoundInvestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roundinvest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case roundinvest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case roundinvest.FieldPlayerID:
		return m.OldPlayerID(ctx)
	case roundinvest.FieldPlayerEmail:
		return m.OldPlayerEmail(ctx)
	case roundinvest.FieldFoldNo:
		return m.OldFoldNo(ctx)
	case roundinvest.FieldLambNum:
		return m.OldLambNum(ctx)
	case roundinvest.FieldProfitAndLoss:
		return m.OldProfitAndLoss(ctx)
	case roundinvest.FieldRoundID:
		return m.OldRoundID(ctx)
	case roundinvest.FieldRoundCount:
		return m.OldRoundCount(ctx)
	case roundinvest.FieldTotalRoundCount:
		return m.OldTotalRoundCount(ctx)
	}
	return nil, fmt.Errorf("unknown RoundInvest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundInvestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roundinvest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case roundinvest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case roundinvest.FieldPlayerID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayerID(v)
		return nil
	case roundinvest.FieldPlayerEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayerEmail(v)
		return nil
	case roundinvest.FieldFoldNo:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFoldNo(v)
		return nil
	case roundinvest.FieldLambNum:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLambNum(v)
		return nil
	case roundinvest.FieldProfitAndLoss:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitAndLoss(v)
		return nil
	case roundinvest.FieldRoundID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundID(v)
		return nil
	case roundinvest.FieldRoundCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundCount(v)
		return nil
	case roundinvest.FieldTotalRoundCount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRoundCount(v)
		return nil
	}
	return fmt.Errorf("unknown RoundInvest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoundInvestMutation) AddedFields() []string {
	var fields []string
	if m.addplayer_id != nil {
		fields = append(fields, roundinvest.FieldPlayerID)
	}
	if m.addfold_no != nil {
		fields = append(fields, roundinvest.FieldFoldNo)
	}
	if m.addlamb_num != nil {
		fields = append(fields, roundinvest.FieldLambNum)
	}
	if m.addprofit_and_loss != nil {
		fields = append(fields, roundinvest.FieldProfitAndLoss)
	}
	if m.addround_count != nil {
		fields = append(fields, roundinvest.FieldRoundCount)
	}
	if m.addtotal_round_count != nil {
		fields = append(fields, roundinvest.FieldTotalRoundCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoundInvestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case roundinvest.FieldPlayerID:
		return m.AddedPlayerID()
	case roundinvest.FieldFoldNo:
		return m.AddedFoldNo()
	case roundinvest.FieldLambNum:
		return m.AddedLambNum()
	case roundinvest.FieldProfitAndLoss:
		return m.AddedProfitAndLoss()
	case roundinvest.FieldRoundCount:
		return m.AddedRoundCount()
	case roundinvest.FieldTotalRoundCount:
		return m.AddedTotalRoundCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundInvestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case roundinvest.FieldPlayerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlayerID(v)
		return nil
	case roundinvest.FieldFoldNo:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFoldNo(v)
		return nil
	case roundinvest.FieldLambNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLambNum(v)
		return nil
	case roundinvest.FieldProfitAndLoss:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitAndLoss(v)
		return nil
	case roundinvest.FieldRoundCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundCount(v)
		return nil
	case roundinvest.FieldTotalRoundCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRoundCount(v)
		return nil
	}
	return fmt.Errorf("unknown RoundInvest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoundInvestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(roundinvest.FieldRoundID) {
		fields = append(fields, roundinvest.FieldRoundID)
	}
	if m.FieldCleared(roundinvest.FieldRoundCount) {
		fields = append(fields, roundinvest.FieldRoundCount)
	}
	if m.FieldCleared(roundinvest.FieldTotalRoundCount) {
		fields = append(fields, roundinvest.FieldTotalRoundCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoundInvestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoundInvestMutation) ClearField(name string) error {
	switch name {
	case roundinvest.FieldRoundID:
		m.ClearRoundID()
		return nil
	case roundinvest.FieldRoundCount:
		m.ClearRoundCount()
		return nil
	case roundinvest.FieldTotalRoundCount:
		m.ClearTotalRoundCount()
		return nil
	}
	return fmt.Errorf("unknown RoundInvest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoundInvestMutation) ResetField(name string) error {
	switch name {
	case roundinvest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case roundinvest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case roundinvest.FieldPlayerID:
		m.ResetPlayerID()
		return nil
	case roundinvest.FieldPlayerEmail:
		m.ResetPlayerEmail()
		return nil
	case roundinvest.FieldFoldNo:
		m.ResetFoldNo()
		return nil
	case roundinvest.FieldLambNum:
		m.ResetLambNum()
		return nil
	case roundinvest.FieldProfitAndLoss:
		m.ResetProfitAndLoss()
		return nil
	case roundinvest.FieldRoundID:
		m.ResetRoundID()
		return nil
	case roundinvest.FieldRoundCount:
		m.ResetRoundCount()
		return nil
	case roundinvest.FieldTotalRoundCount:
		m.ResetTotalRoundCount()
		return nil
	}
	return fmt.Errorf("unknown RoundInvest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoundInvestMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.round != nil {
		edges = append(edges, roundinvest.EdgeRound)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoundInvestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roundinvest.EdgeRound:
		if id := m.round; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoundInvestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoundInvestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoundInvestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedround {
		edges = append(edges, roundinvest.EdgeRound)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoundInvestMutation) EdgeCleared(name string) bool {
	switch name {
	case roundinvest.EdgeRound:
		return m.clearedround
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoundInvestMutation) ClearEdge(name string) error {
	switch name {
	case roundinvest.EdgeRound:
		m.ClearRound()
		return nil
	}
	return fmt.Errorf("unknown RoundInvest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoundInvestMutation) ResetEdge(name string) error {
	switch name {
	case roundinvest.EdgeRound:
		m.ResetRound()
		return nil
	}
	return fmt.Errorf("unknown RoundInvest edge %s", name)
}

// RoundLambFoldMutation represents an operation that mutates the RoundLambFold nodes in the graph.
type RoundLambFoldMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint64
	created_at           *time.Time
	updated_at           *time.Time
	fold_no              *uint32
	addfold_no           *int32
	lamb_num             *uint32
	addlamb_num          *int32
	profit_and_loss      *float32
	addprofit_and_loss   *float32
	round_count          *uint32
	addround_count       *int32
	total_round_count    *uint64
	addtotal_round_count *int64
	clearedFields        map[string]struct{}
	round                *uint64
	clearedround         bool
	done                 bool
	oldValue             func(context.Context) (*RoundLambFold, error)
	predicates           []predicate.RoundLambFold
}

var _ ent.Mutation = (*RoundLambFoldMutation)(nil)

// roundlambfoldOption allows management of the mutation configuration using functional options.
type roundlambfoldOption func(*RoundLambFoldMutation)

// newRoundLambFoldMutation creates new mutation for the RoundLambFold entity.
func newRoundLambFoldMutation(c config, op Op, opts ...roundlambfoldOption) *RoundLambFoldMutation {
	m := &RoundLambFoldMutation{
		config:        c,
		op:            op,
		typ:           TypeRoundLambFold,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoundLambFoldID sets the ID field of the mutation.
func withRoundLambFoldID(id uint64) roundlambfoldOption {
	return func(m *RoundLambFoldMutation) {
		var (
			err   error
			once  sync.Once
			value *RoundLambFold
		)
		m.oldValue = func(ctx context.Context) (*RoundLambFold, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoundLambFold.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoundLambFold sets the old RoundLambFold of the mutation.
func withRoundLambFold(node *RoundLambFold) roundlambfoldOption {
	return func(m *RoundLambFoldMutation) {
		m.oldValue = func(context.Context) (*RoundLambFold, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoundLambFoldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoundLambFoldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RoundLambFold entities.
func (m *RoundLambFoldMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoundLambFoldMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoundLambFoldMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoundLambFold.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoundLambFoldMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoundLambFoldMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RoundLambFold entity.
// If the RoundLambFold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundLambFoldMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoundLambFoldMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoundLambFoldMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoundLambFoldMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RoundLambFold entity.
// If the RoundLambFold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundLambFoldMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoundLambFoldMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFoldNo sets the "fold_no" field.
func (m *RoundLambFoldMutation) SetFoldNo(u uint32) {
	m.fold_no = &u
	m.addfold_no = nil
}

// FoldNo returns the value of the "fold_no" field in the mutation.
func (m *RoundLambFoldMutation) FoldNo() (r uint32, exists bool) {
	v := m.fold_no
	if v == nil {
		return
	}
	return *v, true
}

// OldFoldNo returns the old "fold_no" field's value of the RoundLambFold entity.
// If the RoundLambFold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundLambFoldMutation) OldFoldNo(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFoldNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFoldNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFoldNo: %w", err)
	}
	return oldValue.FoldNo, nil
}

// AddFoldNo adds u to the "fold_no" field.
func (m *RoundLambFoldMutation) AddFoldNo(u int32) {
	if m.addfold_no != nil {
		*m.addfold_no += u
	} else {
		m.addfold_no = &u
	}
}

// AddedFoldNo returns the value that was added to the "fold_no" field in this mutation.
func (m *RoundLambFoldMutation) AddedFoldNo() (r int32, exists bool) {
	v := m.addfold_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetFoldNo resets all changes to the "fold_no" field.
func (m *RoundLambFoldMutation) ResetFoldNo() {
	m.fold_no = nil
	m.addfold_no = nil
}

// SetLambNum sets the "lamb_num" field.
func (m *RoundLambFoldMutation) SetLambNum(u uint32) {
	m.lamb_num = &u
	m.addlamb_num = nil
}

// LambNum returns the value of the "lamb_num" field in the mutation.
func (m *RoundLambFoldMutation) LambNum() (r uint32, exists bool) {
	v := m.lamb_num
	if v == nil {
		return
	}
	return *v, true
}

// OldLambNum returns the old "lamb_num" field's value of the RoundLambFold entity.
// If the RoundLambFold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundLambFoldMutation) OldLambNum(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLambNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLambNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLambNum: %w", err)
	}
	return oldValue.LambNum, nil
}

// AddLambNum adds u to the "lamb_num" field.
func (m *RoundLambFoldMutation) AddLambNum(u int32) {
	if m.addlamb_num != nil {
		*m.addlamb_num += u
	} else {
		m.addlamb_num = &u
	}
}

// AddedLambNum returns the value that was added to the "lamb_num" field in this mutation.
func (m *RoundLambFoldMutation) AddedLambNum() (r int32, exists bool) {
	v := m.addlamb_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetLambNum resets all changes to the "lamb_num" field.
func (m *RoundLambFoldMutation) ResetLambNum() {
	m.lamb_num = nil
	m.addlamb_num = nil
}

// SetRoundID sets the "round_id" field.
func (m *RoundLambFoldMutation) SetRoundID(u uint64) {
	m.round = &u
}

// RoundID returns the value of the "round_id" field in the mutation.
func (m *RoundLambFoldMutation) RoundID() (r uint64, exists bool) {
	v := m.round
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundID returns the old "round_id" field's value of the RoundLambFold entity.
// If the RoundLambFold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundLambFoldMutation) OldRoundID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundID: %w", err)
	}
	return oldValue.RoundID, nil
}

// ClearRoundID clears the value of the "round_id" field.
func (m *RoundLambFoldMutation) ClearRoundID() {
	m.round = nil
	m.clearedFields[roundlambfold.FieldRoundID] = struct{}{}
}

// RoundIDCleared returns if the "round_id" field was cleared in this mutation.
func (m *RoundLambFoldMutation) RoundIDCleared() bool {
	_, ok := m.clearedFields[roundlambfold.FieldRoundID]
	return ok
}

// ResetRoundID resets all changes to the "round_id" field.
func (m *RoundLambFoldMutation) ResetRoundID() {
	m.round = nil
	delete(m.clearedFields, roundlambfold.FieldRoundID)
}

// SetProfitAndLoss sets the "profit_and_loss" field.
func (m *RoundLambFoldMutation) SetProfitAndLoss(f float32) {
	m.profit_and_loss = &f
	m.addprofit_and_loss = nil
}

// ProfitAndLoss returns the value of the "profit_and_loss" field in the mutation.
func (m *RoundLambFoldMutation) ProfitAndLoss() (r float32, exists bool) {
	v := m.profit_and_loss
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitAndLoss returns the old "profit_and_loss" field's value of the RoundLambFold entity.
// If the RoundLambFold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundLambFoldMutation) OldProfitAndLoss(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitAndLoss is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitAndLoss requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitAndLoss: %w", err)
	}
	return oldValue.ProfitAndLoss, nil
}

// AddProfitAndLoss adds f to the "profit_and_loss" field.
func (m *RoundLambFoldMutation) AddProfitAndLoss(f float32) {
	if m.addprofit_and_loss != nil {
		*m.addprofit_and_loss += f
	} else {
		m.addprofit_and_loss = &f
	}
}

// AddedProfitAndLoss returns the value that was added to the "profit_and_loss" field in this mutation.
func (m *RoundLambFoldMutation) AddedProfitAndLoss() (r float32, exists bool) {
	v := m.addprofit_and_loss
	if v == nil {
		return
	}
	return *v, true
}

// ResetProfitAndLoss resets all changes to the "profit_and_loss" field.
func (m *RoundLambFoldMutation) ResetProfitAndLoss() {
	m.profit_and_loss = nil
	m.addprofit_and_loss = nil
}

// SetRoundCount sets the "round_count" field.
func (m *RoundLambFoldMutation) SetRoundCount(u uint32) {
	m.round_count = &u
	m.addround_count = nil
}

// RoundCount returns the value of the "round_count" field in the mutation.
func (m *RoundLambFoldMutation) RoundCount() (r uint32, exists bool) {
	v := m.round_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundCount returns the old "round_count" field's value of the RoundLambFold entity.
// If the RoundLambFold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundLambFoldMutation) OldRoundCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundCount: %w", err)
	}
	return oldValue.RoundCount, nil
}

// AddRoundCount adds u to the "round_count" field.
func (m *RoundLambFoldMutation) AddRoundCount(u int32) {
	if m.addround_count != nil {
		*m.addround_count += u
	} else {
		m.addround_count = &u
	}
}

// AddedRoundCount returns the value that was added to the "round_count" field in this mutation.
func (m *RoundLambFoldMutation) AddedRoundCount() (r int32, exists bool) {
	v := m.addround_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoundCount clears the value of the "round_count" field.
func (m *RoundLambFoldMutation) ClearRoundCount() {
	m.round_count = nil
	m.addround_count = nil
	m.clearedFields[roundlambfold.FieldRoundCount] = struct{}{}
}

// RoundCountCleared returns if the "round_count" field was cleared in this mutation.
func (m *RoundLambFoldMutation) RoundCountCleared() bool {
	_, ok := m.clearedFields[roundlambfold.FieldRoundCount]
	return ok
}

// ResetRoundCount resets all changes to the "round_count" field.
func (m *RoundLambFoldMutation) ResetRoundCount() {
	m.round_count = nil
	m.addround_count = nil
	delete(m.clearedFields, roundlambfold.FieldRoundCount)
}

// SetTotalRoundCount sets the "total_round_count" field.
func (m *RoundLambFoldMutation) SetTotalRoundCount(u uint64) {
	m.total_round_count = &u
	m.addtotal_round_count = nil
}

// TotalRoundCount returns the value of the "total_round_count" field in the mutation.
func (m *RoundLambFoldMutation) TotalRoundCount() (r uint64, exists bool) {
	v := m.total_round_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRoundCount returns the old "total_round_count" field's value of the RoundLambFold entity.
// If the RoundLambFold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundLambFoldMutation) OldTotalRoundCount(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRoundCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRoundCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRoundCount: %w", err)
	}
	return oldValue.TotalRoundCount, nil
}

// AddTotalRoundCount adds u to the "total_round_count" field.
func (m *RoundLambFoldMutation) AddTotalRoundCount(u int64) {
	if m.addtotal_round_count != nil {
		*m.addtotal_round_count += u
	} else {
		m.addtotal_round_count = &u
	}
}

// AddedTotalRoundCount returns the value that was added to the "total_round_count" field in this mutation.
func (m *RoundLambFoldMutation) AddedTotalRoundCount() (r int64, exists bool) {
	v := m.addtotal_round_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalRoundCount clears the value of the "total_round_count" field.
func (m *RoundLambFoldMutation) ClearTotalRoundCount() {
	m.total_round_count = nil
	m.addtotal_round_count = nil
	m.clearedFields[roundlambfold.FieldTotalRoundCount] = struct{}{}
}

// TotalRoundCountCleared returns if the "total_round_count" field was cleared in this mutation.
func (m *RoundLambFoldMutation) TotalRoundCountCleared() bool {
	_, ok := m.clearedFields[roundlambfold.FieldTotalRoundCount]
	return ok
}

// ResetTotalRoundCount resets all changes to the "total_round_count" field.
func (m *RoundLambFoldMutation) ResetTotalRoundCount() {
	m.total_round_count = nil
	m.addtotal_round_count = nil
	delete(m.clearedFields, roundlambfold.FieldTotalRoundCount)
}

// ClearRound clears the "round" edge to the Round entity.
func (m *RoundLambFoldMutation) ClearRound() {
	m.clearedround = true
	m.clearedFields[roundlambfold.FieldRoundID] = struct{}{}
}

// RoundCleared reports if the "round" edge to the Round entity was cleared.
func (m *RoundLambFoldMutation) RoundCleared() bool {
	return m.RoundIDCleared() || m.clearedround
}

// RoundIDs returns the "round" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoundID instead. It exists only for internal usage by the builders.
func (m *RoundLambFoldMutation) RoundIDs() (ids []uint64) {
	if id := m.round; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRound resets all changes to the "round" edge.
func (m *RoundLambFoldMutation) ResetRound() {
	m.round = nil
	m.clearedround = false
}

// Where appends a list predicates to the RoundLambFoldMutation builder.
func (m *RoundLambFoldMutation) Where(ps ...predicate.RoundLambFold) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoundLambFoldMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoundLambFoldMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoundLambFold, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoundLambFoldMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoundLambFoldMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoundLambFold).
func (m *RoundLambFoldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoundLambFoldMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, roundlambfold.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, roundlambfold.FieldUpdatedAt)
	}
	if m.fold_no != nil {
		fields = append(fields, roundlambfold.FieldFoldNo)
	}
	if m.lamb_num != nil {
		fields = append(fields, roundlambfold.FieldLambNum)
	}
	if m.round != nil {
		fields = append(fields, roundlambfold.FieldRoundID)
	}
	if m.profit_and_loss != nil {
		fields = append(fields, roundlambfold.FieldProfitAndLoss)
	}
	if m.round_count != nil {
		fields = append(fields, roundlambfold.FieldRoundCount)
	}
	if m.total_round_count != nil {
		fields = append(fields, roundlambfold.FieldTotalRoundCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoundLambFoldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roundlambfold.FieldCreatedAt:
		return m.CreatedAt()
	case roundlambfold.FieldUpdatedAt:
		return m.UpdatedAt()
	case roundlambfold.FieldFoldNo:
		return m.FoldNo()
	case roundlambfold.FieldLambNum:
		return m.LambNum()
	case roundlambfold.FieldRoundID:
		return m.RoundID()
	case roundlambfold.FieldProfitAndLoss:
		return m.ProfitAndLoss()
	case roundlambfold.FieldRoundCount:
		return m.RoundCount()
	case roundlambfold.FieldTotalRoundCount:
		return m.TotalRoundCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoundLambFoldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roundlambfold.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case roundlambfold.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case roundlambfold.FieldFoldNo:
		return m.OldFoldNo(ctx)
	case roundlambfold.FieldLambNum:
		return m.OldLambNum(ctx)
	case roundlambfold.FieldRoundID:
		return m.OldRoundID(ctx)
	case roundlambfold.FieldProfitAndLoss:
		return m.OldProfitAndLoss(ctx)
	case roundlambfold.FieldRoundCount:
		return m.OldRoundCount(ctx)
	case roundlambfold.FieldTotalRoundCount:
		return m.OldTotalRoundCount(ctx)
	}
	return nil, fmt.Errorf("unknown RoundLambFold field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundLambFoldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roundlambfold.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case roundlambfold.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case roundlambfold.FieldFoldNo:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFoldNo(v)
		return nil
	case roundlambfold.FieldLambNum:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLambNum(v)
		return nil
	case roundlambfold.FieldRoundID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundID(v)
		return nil
	case roundlambfold.FieldProfitAndLoss:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitAndLoss(v)
		return nil
	case roundlambfold.FieldRoundCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundCount(v)
		return nil
	case roundlambfold.FieldTotalRoundCount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRoundCount(v)
		return nil
	}
	return fmt.Errorf("unknown RoundLambFold field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoundLambFoldMutation) AddedFields() []string {
	var fields []string
	if m.addfold_no != nil {
		fields = append(fields, roundlambfold.FieldFoldNo)
	}
	if m.addlamb_num != nil {
		fields = append(fields, roundlambfold.FieldLambNum)
	}
	if m.addprofit_and_loss != nil {
		fields = append(fields, roundlambfold.FieldProfitAndLoss)
	}
	if m.addround_count != nil {
		fields = append(fields, roundlambfold.FieldRoundCount)
	}
	if m.addtotal_round_count != nil {
		fields = append(fields, roundlambfold.FieldTotalRoundCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoundLambFoldMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case roundlambfold.FieldFoldNo:
		return m.AddedFoldNo()
	case roundlambfold.FieldLambNum:
		return m.AddedLambNum()
	case roundlambfold.FieldProfitAndLoss:
		return m.AddedProfitAndLoss()
	case roundlambfold.FieldRoundCount:
		return m.AddedRoundCount()
	case roundlambfold.FieldTotalRoundCount:
		return m.AddedTotalRoundCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundLambFoldMutation) AddField(name string, value ent.Value) error {
	switch name {
	case roundlambfold.FieldFoldNo:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFoldNo(v)
		return nil
	case roundlambfold.FieldLambNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLambNum(v)
		return nil
	case roundlambfold.FieldProfitAndLoss:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitAndLoss(v)
		return nil
	case roundlambfold.FieldRoundCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundCount(v)
		return nil
	case roundlambfold.FieldTotalRoundCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRoundCount(v)
		return nil
	}
	return fmt.Errorf("unknown RoundLambFold numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoundLambFoldMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(roundlambfold.FieldRoundID) {
		fields = append(fields, roundlambfold.FieldRoundID)
	}
	if m.FieldCleared(roundlambfold.FieldRoundCount) {
		fields = append(fields, roundlambfold.FieldRoundCount)
	}
	if m.FieldCleared(roundlambfold.FieldTotalRoundCount) {
		fields = append(fields, roundlambfold.FieldTotalRoundCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoundLambFoldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoundLambFoldMutation) ClearField(name string) error {
	switch name {
	case roundlambfold.FieldRoundID:
		m.ClearRoundID()
		return nil
	case roundlambfold.FieldRoundCount:
		m.ClearRoundCount()
		return nil
	case roundlambfold.FieldTotalRoundCount:
		m.ClearTotalRoundCount()
		return nil
	}
	return fmt.Errorf("unknown RoundLambFold nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoundLambFoldMutation) ResetField(name string) error {
	switch name {
	case roundlambfold.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case roundlambfold.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case roundlambfold.FieldFoldNo:
		m.ResetFoldNo()
		return nil
	case roundlambfold.FieldLambNum:
		m.ResetLambNum()
		return nil
	case roundlambfold.FieldRoundID:
		m.ResetRoundID()
		return nil
	case roundlambfold.FieldProfitAndLoss:
		m.ResetProfitAndLoss()
		return nil
	case roundlambfold.FieldRoundCount:
		m.ResetRoundCount()
		return nil
	case roundlambfold.FieldTotalRoundCount:
		m.ResetTotalRoundCount()
		return nil
	}
	return fmt.Errorf("unknown RoundLambFold field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoundLambFoldMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.round != nil {
		edges = append(edges, roundlambfold.EdgeRound)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoundLambFoldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roundlambfold.EdgeRound:
		if id := m.round; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoundLambFoldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoundLambFoldMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoundLambFoldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedround {
		edges = append(edges, roundlambfold.EdgeRound)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoundLambFoldMutation) EdgeCleared(name string) bool {
	switch name {
	case roundlambfold.EdgeRound:
		return m.clearedround
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoundLambFoldMutation) ClearEdge(name string) error {
	switch name {
	case roundlambfold.EdgeRound:
		m.ClearRound()
		return nil
	}
	return fmt.Errorf("unknown RoundLambFold unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoundLambFoldMutation) ResetEdge(name string) error {
	switch name {
	case roundlambfold.EdgeRound:
		m.ResetRound()
		return nil
	}
	return fmt.Errorf("unknown RoundLambFold edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	status        *uint8
	addstatus     *int8
	name          *string
	module        *string
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id uint64) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Setting entities.
func (m *SettingMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *SettingMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SettingMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *SettingMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SettingMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *SettingMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[setting.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *SettingMutation) StatusCleared() bool {
	_, ok := m.clearedFields[setting.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *SettingMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, setting.FieldStatus)
}

// SetName sets the "name" field.
func (m *SettingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SettingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SettingMutation) ResetName() {
	m.name = nil
}

// SetModule sets the "module" field.
func (m *SettingMutation) SetModule(s string) {
	m.module = &s
}

// Module returns the value of the "module" field in the mutation.
func (m *SettingMutation) Module() (r string, exists bool) {
	v := m.module
	if v == nil {
		return
	}
	return *v, true
}

// OldModule returns the old "module" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldModule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModule: %w", err)
	}
	return oldValue.Module, nil
}

// ResetModule resets all changes to the "module" field.
func (m *SettingMutation) ResetModule() {
	m.module = nil
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, setting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, setting.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, setting.FieldName)
	}
	if m.module != nil {
		fields = append(fields, setting.FieldModule)
	}
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldCreatedAt:
		return m.CreatedAt()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	case setting.FieldStatus:
		return m.Status()
	case setting.FieldName:
		return m.Name()
	case setting.FieldModule:
		return m.Module()
	case setting.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case setting.FieldStatus:
		return m.OldStatus(ctx)
	case setting.FieldName:
		return m.OldName(ctx)
	case setting.FieldModule:
		return m.OldModule(ctx)
	case setting.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case setting.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case setting.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case setting.FieldModule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModule(v)
		return nil
	case setting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, setting.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case setting.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setting.FieldStatus) {
		fields = append(fields, setting.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	switch name {
	case setting.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case setting.FieldStatus:
		m.ResetStatus()
		return nil
	case setting.FieldName:
		m.ResetName()
		return nil
	case setting.FieldModule:
		m.ResetModule()
		return nil
	case setting.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}
